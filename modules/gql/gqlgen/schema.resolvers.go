package gqlgen

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"encoding/base64"
	"fmt"
	"math"
	"os"
	"strings"
	"unicode/utf8"
	"vsc-node/lib/datalayer"
	"vsc-node/modules/announcements"
	"vsc-node/modules/common"
	"vsc-node/modules/common/params"
	"vsc-node/modules/db/vsc/contracts"
	"vsc-node/modules/db/vsc/elections"
	ledgerDb "vsc-node/modules/db/vsc/ledger"
	"vsc-node/modules/db/vsc/nonces"
	rcDb "vsc-node/modules/db/vsc/rcs"
	"vsc-node/modules/db/vsc/transactions"
	"vsc-node/modules/db/vsc/witnesses"
	"vsc-node/modules/gql/model"
	ledgerSystem "vsc-node/modules/ledger-system"
	stateEngine "vsc-node/modules/state-processing"
	transactionpool "vsc-node/modules/transaction-pool"

	"github.com/ipfs/go-cid"
	"go.mongodb.org/mongo-driver/mongo"
)

// Amount is the resolver for the amount field.
func (r *actionRecordResolver) Amount(ctx context.Context, obj *ledgerDb.ActionRecord) (model.Int64, error) {
	return model.Int64(obj.Amount), nil
}

// ActionID is the resolver for the action_id field.
func (r *actionRecordResolver) ActionID(ctx context.Context, obj *ledgerDb.ActionRecord) (string, error) {
	return obj.TxId, nil
}

// Params is the resolver for the params field.
func (r *actionRecordResolver) Params(ctx context.Context, obj *ledgerDb.ActionRecord) (model.Map, error) {
	return model.Map(obj.Params), nil
}

// BlockHeight is the resolver for the block_height field.
func (r *actionRecordResolver) BlockHeight(ctx context.Context, obj *ledgerDb.ActionRecord) (model.Uint64, error) {
	return model.Uint64(obj.BlockHeight), nil
}

// BlockHeight is the resolver for the block_height field.
func (r *balanceRecordResolver) BlockHeight(ctx context.Context, obj *ledgerDb.BalanceRecord) (model.Uint64, error) {
	return model.Uint64(obj.BlockHeight), nil
}

// Hbd is the resolver for the hbd field.
func (r *balanceRecordResolver) Hbd(ctx context.Context, obj *ledgerDb.BalanceRecord) (model.Int64, error) {
	return model.Int64(obj.HBD), nil
}

// HbdAvg is the resolver for the hbd_avg field.
func (r *balanceRecordResolver) HbdAvg(ctx context.Context, obj *ledgerDb.BalanceRecord) (model.Int64, error) {
	return model.Int64(obj.HBD_AVG), nil
}

// HbdModify is the resolver for the hbd_modify field.
func (r *balanceRecordResolver) HbdModify(ctx context.Context, obj *ledgerDb.BalanceRecord) (model.Uint64, error) {
	return model.Uint64(obj.HBD_MODIFY_HEIGHT), nil
}

// HbdClaim is the resolver for the hbd_claim field.
func (r *balanceRecordResolver) HbdClaim(ctx context.Context, obj *ledgerDb.BalanceRecord) (model.Uint64, error) {
	return model.Uint64(obj.HBD_CLAIM_HEIGHT), nil
}

// HbdSavings is the resolver for the hbd_savings field.
func (r *balanceRecordResolver) HbdSavings(ctx context.Context, obj *ledgerDb.BalanceRecord) (model.Int64, error) {
	return model.Int64(obj.HBD_SAVINGS), nil
}

// Hive is the resolver for the hive field.
func (r *balanceRecordResolver) Hive(ctx context.Context, obj *ledgerDb.BalanceRecord) (model.Int64, error) {
	return model.Int64(obj.Hive), nil
}

// HiveConsensus is the resolver for the hive_consensus field.
func (r *balanceRecordResolver) HiveConsensus(ctx context.Context, obj *ledgerDb.BalanceRecord) (model.Int64, error) {
	return model.Int64(obj.HIVE_CONSENSUS), nil
}

// ConsensusUnstaking is the resolver for the consensus_unstaking field.
func (r *balanceRecordResolver) ConsensusUnstaking(ctx context.Context, obj *ledgerDb.BalanceRecord) (model.Int64, error) {
	amt, err := r.Actions.GetAccountPendingConsensusUnstake(obj.Account)
	return model.Int64(amt), err
}

// PendingHbdUnstaking is the resolver for the pending_hbd_unstaking field.
func (r *balanceRecordResolver) PendingHbdUnstaking(ctx context.Context, obj *ledgerDb.BalanceRecord) (*model.Int64, error) {
	doc, _ := r.HiveBlocks.GetMetadata()

	startBlk := doc.LastProcessedBlock
	endBlk := *startBlk + common.HBD_UNSTAKE_BLOCKS
	asset := ledgerDb.AssetHbd
	ledgerRecords, err := r.Ledger.GetRawLedgerRange(&obj.Account, nil, []string{"unstake"}, &asset, startBlk, &endBlk, 0, 900)

	if err != nil {
		return nil, err
	}
	bal := int64(0)
	for _, record := range ledgerRecords {
		bal += record.Amount
	}
	ret := model.Int64(bal)
	return &ret, nil
}

// CreationHeight is the resolver for the creation_height field.
func (r *contractResolver) CreationHeight(ctx context.Context, obj *contracts.Contract) (model.Uint64, error) {
	return model.Uint64(obj.CreationHeight), nil
}

// Runtime is the resolver for the runtime field.
func (r *contractResolver) Runtime(ctx context.Context, obj *contracts.Contract) (string, error) {
	return obj.Runtime.String(), nil
}

// BlockHeight is the resolver for the block_height field.
func (r *contractOutputResolver) BlockHeight(ctx context.Context, obj *contracts.ContractOutput) (model.Int64, error) {
	return model.Int64(obj.BlockHeight), nil
}

// Epoch is the resolver for the epoch field.
func (r *electionResultResolver) Epoch(ctx context.Context, obj *elections.ElectionResult) (model.Uint64, error) {
	return model.Uint64(obj.Epoch), nil
}

// Weights is the resolver for the weights field.
func (r *electionResultResolver) Weights(ctx context.Context, obj *elections.ElectionResult) ([]model.Uint64, error) {
	converted := make([]model.Uint64, len(obj.Weights))
	for i, v := range obj.Weights {
		converted[i] = model.Uint64(v)
	}
	return converted, nil
}

// ProtocolVersion is the resolver for the protocol_version field.
func (r *electionResultResolver) ProtocolVersion(ctx context.Context, obj *elections.ElectionResult) (model.Uint64, error) {
	return model.Uint64(obj.ProtocolVersion), nil
}

// TotalWeight is the resolver for the total_weight field.
func (r *electionResultResolver) TotalWeight(ctx context.Context, obj *elections.ElectionResult) (model.Uint64, error) {
	return model.Uint64(obj.TotalWeight), nil
}

// BlockHeight is the resolver for the block_height field.
func (r *electionResultResolver) BlockHeight(ctx context.Context, obj *elections.ElectionResult) (model.Uint64, error) {
	return model.Uint64(obj.BlockHeight), nil
}

// Amount is the resolver for the amount field.
func (r *ledgerRecordResolver) Amount(ctx context.Context, obj *ledgerDb.LedgerRecord) (model.Int64, error) {
	return model.Int64(obj.Amount), nil
}

// BlockHeight is the resolver for the block_height field.
func (r *ledgerRecordResolver) BlockHeight(ctx context.Context, obj *ledgerDb.LedgerRecord) (model.Uint64, error) {
	return model.Uint64(obj.BlockHeight), nil
}

// Nonce is the resolver for the nonce field.
func (r *nonceRecordResolver) Nonce(ctx context.Context, obj *nonces.NonceRecord) (model.Uint64, error) {
	return model.Uint64(obj.Nonce), nil
}

// Amount is the resolver for the amount field.
func (r *opLogEventResolver) Amount(ctx context.Context, obj *ledgerSystem.OpLogEvent) (model.Int64, error) {
	return model.Int64(obj.Amount), nil
}

// Params is the resolver for the params field.
func (r *opLogEventResolver) Params(ctx context.Context, obj *ledgerSystem.OpLogEvent) (model.Map, error) {
	return model.Map(obj.Params), nil
}

// Ct is the resolver for the ct field.
func (r *postingJsonKeysResolver) Ct(ctx context.Context, obj *witnesses.PostingJsonKeys) (*string, error) {
	return &obj.CryptoType, nil
}

// T is the resolver for the t field.
func (r *postingJsonKeysResolver) T(ctx context.Context, obj *witnesses.PostingJsonKeys) (*string, error) {
	return &obj.Type, nil
}

// GetStateByKeys is the resolver for the getStateByKeys field.
func (r *queryResolver) GetStateByKeys(ctx context.Context, contractID string, keys []string) (model.Map, error) {
	if len(keys) < 1 || len(keys) > 100 {
		return nil, fmt.Errorf("number of state keys to query must be between 1 and 100")
	}
	output, err := r.ContractsState.GetLastOutput(contractID, math.MaxInt64)
	if err != nil {
		return nil, err
	}
	cidz, err := cid.Parse(output.StateMerkle)
	if err != nil {
		return nil, err
	}
	databin := datalayer.NewDataBinFromCid(r.Da, cidz)
	result := make(map[string]interface{})
	var keyErr error
	for _, key := range keys {
		cidVal, err := databin.Get(key)
		if err != nil {
			if err == os.ErrNotExist {
				result[key] = nil
			} else {
				keyErr = err
			}
			continue
		}
		rawVal, err := r.Da.GetRaw(*cidVal)
		if err != nil {
			keyErr = err
			continue
		}
		result[key] = string(rawVal)
	}
	return model.Map(result), keyErr
}

// FindTransaction is the resolver for the findTransaction field.
func (r *queryResolver) FindTransaction(ctx context.Context, filterOptions *TransactionFilter) ([]transactions.TransactionRecord, error) {
	if filterOptions == nil {
		filterOptions = &TransactionFilter{}
	}
	offset, limit, paginateErr := Paginate(filterOptions.Offset, filterOptions.Limit)
	if paginateErr != nil {
		return nil, paginateErr
	}

	return r.Transactions.FindTransactions(filterOptions.ByIds, filterOptions.ByID, filterOptions.ByAccount, filterOptions.ByContract, filterOptions.ByStatus, filterOptions.ByType, filterOptions.ByLedgerToFrom, filterOptions.ByLedgerTypes, (*uint64)(filterOptions.FromBlock), (*uint64)(filterOptions.ToBlock), offset, limit)
}

// FindContractOutput is the resolver for the findContractOutput field.
func (r *queryResolver) FindContractOutput(ctx context.Context, filterOptions *ContractOutputFilter) ([]contracts.ContractOutput, error) {
	if filterOptions == nil {
		filterOptions = &ContractOutputFilter{}
	}
	offset, limit, paginateErr := Paginate(filterOptions.Offset, filterOptions.Limit)
	if paginateErr != nil {
		return nil, paginateErr
	}
	return r.ContractsState.FindOutputs(filterOptions.ByID, filterOptions.ByInput, filterOptions.ByContract, (*uint64)(filterOptions.FromBlock), (*uint64)(filterOptions.ToBlock), offset, limit)
}

// FindLedgerTXs is the resolver for the findLedgerTXs field.
func (r *queryResolver) FindLedgerTXs(ctx context.Context, filterOptions *LedgerTxFilter) ([]ledgerDb.LedgerRecord, error) {
	if filterOptions == nil {
		filterOptions = &LedgerTxFilter{}
	}
	offset, limit, paginateErr := Paginate(filterOptions.Offset, filterOptions.Limit)
	if paginateErr != nil {
		return nil, paginateErr
	}
	if filterOptions.ByTxID != nil && utf8.RuneCountInString(*filterOptions.ByTxID) < 40 {
		return nil, fmt.Errorf("invalid tx id")
	}
	return r.Ledger.GetLedgersTsRange(filterOptions.ByToFrom, filterOptions.ByTxID, filterOptions.ByTypes, filterOptions.ByAsset, (*uint64)(filterOptions.FromBlock), (*uint64)(filterOptions.ToBlock), offset, limit)
}

// FindLedgerActions is the resolver for the findLedgerActions field.
func (r *queryResolver) FindLedgerActions(ctx context.Context, filterOptions *LedgerActionsFilter) ([]ledgerDb.ActionRecord, error) {
	if filterOptions == nil {
		filterOptions = &LedgerActionsFilter{}
	}
	offset, limit, paginateErr := Paginate(filterOptions.Offset, filterOptions.Limit)
	if paginateErr != nil {
		return nil, paginateErr
	}
	if filterOptions.ByTxID != nil && utf8.RuneCountInString(*filterOptions.ByTxID) < 40 {
		return nil, fmt.Errorf("invalid tx id")
	}
	return r.Actions.GetActionsRange(filterOptions.ByTxID, filterOptions.ByActionID, filterOptions.ByAccount, filterOptions.ByTypes, filterOptions.ByAsset, filterOptions.ByStatus, (*uint64)(filterOptions.FromBlock), (*uint64)(filterOptions.ToBlock), offset, limit)
}

// GetAccountBalance is the resolver for the getAccountBalance field.
func (r *queryResolver) GetAccountBalance(ctx context.Context, account string, height *model.Uint64) (*ledgerDb.BalanceRecord, error) {
	if account == "" {
		return nil, fmt.Errorf("account parameter cannot be empty")
	}
	blockHeight := ParseHeight(height)
	return r.Balances.GetBalanceRecord(account, blockHeight)
}

// GetAccountRc is the resolver for the getAccountRC field.
func (r *queryResolver) GetAccountRc(ctx context.Context, account string, height *model.Uint64) (*rcDb.RcRecord, error) {
	if account == "" {
		return nil, fmt.Errorf("account parameter cannot be empty")
	}
	blockHeight := ParseHeight(height)

	var highestHeight uint64
	if height == nil {
		highestBlock, err := r.HiveBlocks.GetHighestBlock()
		if err != nil {
			return nil, fmt.Errorf("failed to get highest block: %w", err)
		}
		highestHeight = highestBlock
	} else {
		highestHeight = uint64(*height)
	}

	maxRcs := int64(0)
	amount := int64(0)

	if strings.HasPrefix(account, "hive:") {
		fmt.Println("account", account, "is hive account")
		maxRcs = maxRcs + params.RC_HIVE_FREE_AMOUNT
		amount = params.RC_HIVE_FREE_AMOUNT
	}

	balRecord, err := r.Balances.GetBalanceRecord(account, blockHeight)

	if err == mongo.ErrNoDocuments {
		return &rcDb.RcRecord{
			Account:     account,
			Amount:      amount,
			MaxRcs:      maxRcs,
			BlockHeight: blockHeight,
		}, nil
	}

	rcRecord, err := r.Rc.GetRecord(account, blockHeight)

	if err == mongo.ErrNoDocuments {
		return &rcDb.RcRecord{
			Account:     account,
			Amount:      amount,
			MaxRcs:      maxRcs,
			BlockHeight: blockHeight,
		}, nil
	}

	//Add MAX RC balance from HBD
	maxRcs = maxRcs + balRecord.HBD
	//Add available RCs from HBD; this may be changed later
	amount = amount + balRecord.HBD

	//Get number of blocks that have elapsed since the last RC update
	diff := highestHeight - rcRecord.BlockHeight

	//Total amount of RCs (i.e amount unfrozen)
	amtRet := int64(diff * uint64(rcRecord.Amount) / params.RC_RETURN_PERIOD)

	//Prevent overflow when the return period is greater than RC_RETURN_PERIOD
	if amtRet > rcRecord.Amount {
		amtRet = rcRecord.Amount
	}

	//Subject the returned amount from the currently frozen RCs
	frozenAmount := rcRecord.Amount - amtRet
	//Subtract frozen RCs - regenerated RCs
	amount = amount - frozenAmount

	return &rcDb.RcRecord{
		Account:     account,
		Amount:      amount,
		MaxRcs:      maxRcs,
		BlockHeight: blockHeight,
	}, nil
}

// FindContract is the resolver for the findContract field.
func (r *queryResolver) FindContract(ctx context.Context, filterOptions *FindContractFilter) ([]contracts.Contract, error) {
	if filterOptions == nil {
		filterOptions = &FindContractFilter{}
	}
	offset, limit, paginateErr := Paginate(filterOptions.Offset, filterOptions.Limit)
	if paginateErr != nil {
		return nil, paginateErr
	}
	return r.Contracts.FindContracts(filterOptions.ByID, filterOptions.ByCode, filterOptions.Historical, offset, limit)
}

// SubmitTransactionV1 is the resolver for the submitTransactionV1 field.
func (r *queryResolver) SubmitTransactionV1(ctx context.Context, tx string, sig string) (*TransactionSubmitResult, error) {
	Tx, err := base64.URLEncoding.DecodeString(tx)
	if err != nil {
		return nil, err
	}
	Sig, err := base64.URLEncoding.DecodeString(sig)
	if err != nil {
		return nil, err
	}
	cid, err := r.TxPool.IngestTx(transactionpool.SerializedVSCTransaction{
		Tx:  Tx,
		Sig: Sig,
	})
	if err != nil {
		return nil, err
	}
	id := cid.String()
	return &TransactionSubmitResult{
		ID: &id,
	}, nil
}

// GetAccountNonce is the resolver for the getAccountNonce field.
func (r *queryResolver) GetAccountNonce(ctx context.Context, account string) (*nonces.NonceRecord, error) {
	record, err := r.Nonces.GetNonce(account)

	if err == mongo.ErrNoDocuments {
		return &nonces.NonceRecord{
			Account: account,
			Nonce:   0,
		}, nil
	}
	return &record, err
}

// LocalNodeInfo is the resolver for the localNodeInfo field.
func (r *queryResolver) LocalNodeInfo(ctx context.Context) (*LocalNodeInfo, error) {
	head, headErr := r.HiveBlocks.GetLastProcessedBlock()
	if headErr != nil {
		return nil, headErr
	}
	election, electionErr := r.Elections.GetElectionByHeight(head)
	if electionErr != nil {
		return nil, electionErr
	}
	return &LocalNodeInfo{GitCommit: announcements.GitCommit, VersionID: announcements.VersionId, LastProcessedBlock: model.Uint64(head), Epoch: model.Uint64(election.Epoch)}, nil
}

// GetWitness is the resolver for the getWitness field.
func (r *queryResolver) GetWitness(ctx context.Context, account string, height *model.Uint64) (*witnesses.Witness, error) {
	blockHeight := ParseHeight(height)
	return r.Witnesses.GetWitnessAtHeight(account, &blockHeight)
}

// WitnessNodes is the resolver for the witnessNodes field.
func (r *queryResolver) WitnessNodes(ctx context.Context, height model.Uint64) ([]witnesses.Witness, error) {
	return r.Witnesses.GetWitnessesAtBlockHeight(uint64(height))
}

// WitnessSchedule is the resolver for the witnessSchedule field.
func (r *queryResolver) WitnessSchedule(ctx context.Context, height model.Uint64) ([]stateEngine.WitnessSlot, error) {
	slotInfo := stateEngine.CalculateSlotInfo(uint64(height))
	schedule := r.StateEngine.GetSchedule(slotInfo.StartHeight)
	return schedule, nil
}

// WitnessStake is the resolver for the witnessStake field.
func (r *queryResolver) WitnessStake(ctx context.Context, account string) (model.Uint64, error) {
	res, err := r.Balances.GetBalanceRecord(account, uint64(math.MaxInt64))
	if err != nil {
		return 0, err
	}
	if res == nil {
		return 0, nil
	}
	return model.Uint64(res.HIVE_CONSENSUS), nil
}

// GetDagByCid is the resolver for the getDagByCID field.
func (r *queryResolver) GetDagByCid(ctx context.Context, cidString string) (string, error) {
	blockCid, parseErr := cid.Parse(cidString)
	if parseErr != nil {
		return "", parseErr
	}
	node, nodeErr := r.Da.GetDag(blockCid)
	if nodeErr != nil {
		return "", nodeErr
	}
	jsonBytes, jsonErr := node.MarshalJSON()
	if jsonErr != nil {
		return "", jsonErr
	}
	return string(jsonBytes), nil
}

// GetElection is the resolver for the getElection field.
func (r *queryResolver) GetElection(ctx context.Context, epoch model.Uint64) (*elections.ElectionResult, error) {
	result := r.Elections.GetElection(uint64(epoch))
	if result == nil {
		return nil, fmt.Errorf("election not found or error occurred for epoch %d", uint64(epoch))
	}
	return result, nil
}

// ElectionByBlockHeight is the resolver for the electionByBlockHeight field.
func (r *queryResolver) ElectionByBlockHeight(ctx context.Context, blockHeight *model.Uint64) (*elections.ElectionResult, error) {
	bh := uint64(math.MaxInt64)
	if blockHeight != nil {
		bh = uint64(*blockHeight)
	}
	res, err := r.Elections.GetElectionByHeight(bh)
	return &res, err
}

// GetTssKey is the resolver for the getTssKey field.
func (r *queryResolver) GetTssKey(ctx context.Context, keyID string) (*TssKey, error) {
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	default:
	}

	t, err := r.TssKeys.FindKey(keyID)
	if err != nil {
		return nil, err
	}

	tssKey := &TssKey{
		ID:            keyID,
		Status:        t.Status,
		PublicKey:     t.PublicKey,
		Owner:         t.Owner,
		Algo:          string(t.Algo),
		CreatedHeight: int(t.CreatedHeight),
	}

	return tssKey, nil
}

// GetTssRequests is the resolver for the getTssRequests field.
func (r *queryResolver) GetTssRequests(ctx context.Context, keyID string, msgHex []string) ([]TssRequest, error) {
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	default:
	}

	t, err := r.TssRequests.FindRequests(keyID, msgHex)
	if err != nil {
		return nil, err
	}

	tssRequests := make([]TssRequest, len(t))
	for i := range t {
		tr := &t[i]

		tssRequests[i] = TssRequest{
			ID:     tr.Id,
			Status: string(tr.Status),
			KeyID:  keyID,
			Msg:    tr.Msg,
			Sig:    tr.Sig,
		}
	}

	return tssRequests, nil
}

// Amount is the resolver for the amount field.
func (r *rcRecordResolver) Amount(ctx context.Context, obj *rcDb.RcRecord) (model.Int64, error) {
	return model.Int64(obj.Amount), nil
}

// BlockHeight is the resolver for the block_height field.
func (r *rcRecordResolver) BlockHeight(ctx context.Context, obj *rcDb.RcRecord) (model.Uint64, error) {
	return model.Uint64(obj.BlockHeight), nil
}

// MaxRcs is the resolver for the max_rcs field.
func (r *rcRecordResolver) MaxRcs(ctx context.Context, obj *rcDb.RcRecord) (model.Int64, error) {
	return model.Int64(obj.MaxRcs), nil
}

// Index is the resolver for the index field.
func (r *transactionOperationResolver) Index(ctx context.Context, obj *transactions.TransactionOperation) (model.Uint64, error) {
	return model.Uint64(obj.Idx), nil
}

// Data is the resolver for the data field.
func (r *transactionOperationResolver) Data(ctx context.Context, obj *transactions.TransactionOperation) (model.Map, error) {
	return model.Map(obj.Data), nil
}

// AnchrHeight is the resolver for the anchr_height field.
func (r *transactionRecordResolver) AnchrHeight(ctx context.Context, obj *transactions.TransactionRecord) (model.Uint64, error) {
	return model.Uint64(obj.AnchoredHeight), nil
}

// AnchrIndex is the resolver for the anchr_index field.
func (r *transactionRecordResolver) AnchrIndex(ctx context.Context, obj *transactions.TransactionRecord) (model.Uint64, error) {
	return model.Uint64(obj.AnchoredIndex), nil
}

// AnchrID is the resolver for the anchr_id field.
func (r *transactionRecordResolver) AnchrID(ctx context.Context, obj *transactions.TransactionRecord) (*string, error) {
	return obj.AnchoredId, nil
}

// AnchrTs is the resolver for the anchr_ts field.
func (r *transactionRecordResolver) AnchrTs(ctx context.Context, obj *transactions.TransactionRecord) (*string, error) {
	return obj.AnchoredTs, nil
}

// Nonce is the resolver for the nonce field.
func (r *transactionRecordResolver) Nonce(ctx context.Context, obj *transactions.TransactionRecord) (model.Uint64, error) {
	return model.Uint64(obj.Nonce), nil
}

// RcLimit is the resolver for the rc_limit field.
func (r *transactionRecordResolver) RcLimit(ctx context.Context, obj *transactions.TransactionRecord) (model.Uint64, error) {
	return model.Uint64(obj.RcLimit), nil
}

// LedgerActions is the resolver for the ledger_actions field.
func (r *transactionRecordResolver) LedgerActions(ctx context.Context, obj *transactions.TransactionRecord) ([]*LedgerAction, error) {
	lrs, err := r.Actions.GetActionsByTxId(obj.Id)
	if err != nil {
		return nil, err
	}
	actions := make([]*LedgerAction, len(lrs))
	for i, lr := range lrs {
		amt := model.Uint64(lr.Amount)
		actions[i] = &LedgerAction{
			ID:     &lr.Id,
			Status: &lr.Status,
			Amount: &amt,
			Asset:  &lr.Asset,
			To:     &lr.To,
			Memo:   &lr.Memo,
			Type:   &lr.Type,
			Data:   model.Map(lr.Params),
		}
	}
	return actions, nil
}

// Height is the resolver for the height field.
func (r *witnessResolver) Height(ctx context.Context, obj *witnesses.Witness) (model.Uint64, error) {
	return model.Uint64(obj.Height), nil
}

// ProtocolVersion is the resolver for the protocol_version field.
func (r *witnessResolver) ProtocolVersion(ctx context.Context, obj *witnesses.Witness) (model.Uint64, error) {
	return model.Uint64(obj.ProtocolVersion), nil
}

// Bn is the resolver for the bn field.
func (r *witnessSlotResolver) Bn(ctx context.Context, obj *stateEngine.WitnessSlot) (model.Uint64, error) {
	return model.Uint64(obj.SlotHeight), nil
}

// ActionRecord returns ActionRecordResolver implementation.
func (r *Resolver) ActionRecord() ActionRecordResolver { return &actionRecordResolver{r} }

// BalanceRecord returns BalanceRecordResolver implementation.
func (r *Resolver) BalanceRecord() BalanceRecordResolver { return &balanceRecordResolver{r} }

// Contract returns ContractResolver implementation.
func (r *Resolver) Contract() ContractResolver { return &contractResolver{r} }

// ContractOutput returns ContractOutputResolver implementation.
func (r *Resolver) ContractOutput() ContractOutputResolver { return &contractOutputResolver{r} }

// ElectionResult returns ElectionResultResolver implementation.
func (r *Resolver) ElectionResult() ElectionResultResolver { return &electionResultResolver{r} }

// LedgerRecord returns LedgerRecordResolver implementation.
func (r *Resolver) LedgerRecord() LedgerRecordResolver { return &ledgerRecordResolver{r} }

// NonceRecord returns NonceRecordResolver implementation.
func (r *Resolver) NonceRecord() NonceRecordResolver { return &nonceRecordResolver{r} }

// OpLogEvent returns OpLogEventResolver implementation.
func (r *Resolver) OpLogEvent() OpLogEventResolver { return &opLogEventResolver{r} }

// PostingJsonKeys returns PostingJsonKeysResolver implementation.
func (r *Resolver) PostingJsonKeys() PostingJsonKeysResolver { return &postingJsonKeysResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// RcRecord returns RcRecordResolver implementation.
func (r *Resolver) RcRecord() RcRecordResolver { return &rcRecordResolver{r} }

// TransactionOperation returns TransactionOperationResolver implementation.
func (r *Resolver) TransactionOperation() TransactionOperationResolver {
	return &transactionOperationResolver{r}
}

// TransactionRecord returns TransactionRecordResolver implementation.
func (r *Resolver) TransactionRecord() TransactionRecordResolver {
	return &transactionRecordResolver{r}
}

// Witness returns WitnessResolver implementation.
func (r *Resolver) Witness() WitnessResolver { return &witnessResolver{r} }

// WitnessSlot returns WitnessSlotResolver implementation.
func (r *Resolver) WitnessSlot() WitnessSlotResolver { return &witnessSlotResolver{r} }

type actionRecordResolver struct{ *Resolver }
type balanceRecordResolver struct{ *Resolver }
type contractResolver struct{ *Resolver }
type contractOutputResolver struct{ *Resolver }
type electionResultResolver struct{ *Resolver }
type ledgerRecordResolver struct{ *Resolver }
type nonceRecordResolver struct{ *Resolver }
type opLogEventResolver struct{ *Resolver }
type postingJsonKeysResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type rcRecordResolver struct{ *Resolver }
type transactionOperationResolver struct{ *Resolver }
type transactionRecordResolver struct{ *Resolver }
type witnessResolver struct{ *Resolver }
type witnessSlotResolver struct{ *Resolver }
