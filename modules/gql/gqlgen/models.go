// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlgen

import (
	"fmt"
	"io"
	"strconv"
	"vsc-node/modules/db/vsc/contracts"
	ledgerDb "vsc-node/modules/db/vsc/ledger"
	"vsc-node/modules/db/vsc/transactions"
	"vsc-node/modules/gql/model"
)

type BalanceAccessCondition interface {
	IsBalanceAccessCondition()
	GetType() *BalanceAccessConditionType
	GetValue() *string
}

type BalanceController interface {
	IsBalanceController()
	GetType() *BalanceControllerType
	GetAuthority() *string
	GetConditions() []BalanceAccessCondition
}

type BlockRef interface {
	IsBlockRef()
	GetBlockRef() *string
	GetIncludedBlock() *int
}

type DepositDrain interface {
	IsDepositDrain()
	GetDepositID() *string
	GetAmount() *float64
	GetToken() *string
	GetOwner() *string
}

type AnchorProducer struct {
	NextSlot *string `json:"nextSlot,omitempty"`
}

type Contract struct {
	ID         *string `json:"id,omitempty"`
	Code       *string `json:"code,omitempty"`
	CreationTs *string `json:"creation_ts,omitempty"`
}

type ContractDiff struct {
	Diff                    *string `json:"diff,omitempty"`
	PreviousContractStateID string  `json:"previousContractStateId"`
}

type FindContractOutputFilter struct {
	ByInput    *string `json:"byInput,omitempty"`
	ByOutput   *string `json:"byOutput,omitempty"`
	ByContract *string `json:"byContract,omitempty"`
	Limit      *int    `json:"limit,omitempty"`
}

type FindContractOutputResult struct {
	Outputs []*contracts.ContractOutput `json:"outputs,omitempty"`
}

type FindContractResult struct {
	Status *string `json:"status,omitempty"`
}

type Gas struct {
	Io *int `json:"IO,omitempty"`
}

type LedgerActionsFilter struct {
	ByTxID     *string         `json:"byTxId,omitempty"`
	ByActionID *string         `json:"byActionId,omitempty"`
	ByAccount  *string         `json:"byAccount,omitempty"`
	ByTypes    []string        `json:"byTypes,omitempty"`
	ByAsset    *ledgerDb.Asset `json:"byAsset,omitempty"`
	ByStatus   *string         `json:"byStatus,omitempty"`
	FromBlock  *model.Uint64   `json:"fromBlock,omitempty"`
	ToBlock    *model.Uint64   `json:"toBlock,omitempty"`
	Offset     *int            `json:"offset,omitempty"`
	Limit      *int            `json:"limit,omitempty"`
}

type LedgerTxFilter struct {
	ByToFrom  *string         `json:"byToFrom,omitempty"`
	ByTxID    *string         `json:"byTxId,omitempty"`
	ByTypes   []string        `json:"byTypes,omitempty"`
	ByAsset   *ledgerDb.Asset `json:"byAsset,omitempty"`
	FromBlock *model.Uint64   `json:"fromBlock,omitempty"`
	ToBlock   *model.Uint64   `json:"toBlock,omitempty"`
	Offset    *int            `json:"offset,omitempty"`
	Limit     *int            `json:"limit,omitempty"`
}

type LocalNodeInfo struct {
	VersionID          string       `json:"version_id"`
	GitCommit          string       `json:"git_commit"`
	LastProcessedBlock model.Uint64 `json:"last_processed_block"`
	Epoch              model.Uint64 `json:"epoch"`
}

type Mutation struct {
}

type Query struct {
}

type TestResult struct {
	CurrentNumber *int `json:"currentNumber,omitempty"`
}

type TransactionData struct {
	Op         string  `json:"op"`
	Action     *string `json:"action,omitempty"`
	Payload    *string `json:"payload,omitempty"`
	ContractID *string `json:"contract_id,omitempty"`
}

type TransactionFilter struct {
	ByID           *string                         `json:"byId,omitempty"`
	ByIds          []string                        `json:"byIds,omitempty"`
	ByAccount      *string                         `json:"byAccount,omitempty"`
	ByContract     *string                         `json:"byContract,omitempty"`
	ByStatus       *transactions.TransactionStatus `json:"byStatus,omitempty"`
	ByType         *string                         `json:"byType,omitempty"`
	ByLedgerToFrom *string                         `json:"byLedgerToFrom,omitempty"`
	ByLedgerTypes  []string                        `json:"byLedgerTypes,omitempty"`
	Offset         *int                            `json:"offset,omitempty"`
	Limit          *int                            `json:"limit,omitempty"`
}

type TransactionOutput struct {
	Index *int    `json:"index,omitempty"`
	ID    *string `json:"id,omitempty"`
}

type TransactionSubmitResult struct {
	ID *string `json:"id,omitempty"`
}

type BalanceAccessConditionType string

const (
	BalanceAccessConditionTypeTime     BalanceAccessConditionType = "TIME"
	BalanceAccessConditionTypeHash     BalanceAccessConditionType = "HASH"
	BalanceAccessConditionTypeWithdraw BalanceAccessConditionType = "WITHDRAW"
)

var AllBalanceAccessConditionType = []BalanceAccessConditionType{
	BalanceAccessConditionTypeTime,
	BalanceAccessConditionTypeHash,
	BalanceAccessConditionTypeWithdraw,
}

func (e BalanceAccessConditionType) IsValid() bool {
	switch e {
	case BalanceAccessConditionTypeTime, BalanceAccessConditionTypeHash, BalanceAccessConditionTypeWithdraw:
		return true
	}
	return false
}

func (e BalanceAccessConditionType) String() string {
	return string(e)
}

func (e *BalanceAccessConditionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BalanceAccessConditionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BalanceAccessConditionType", str)
	}
	return nil
}

func (e BalanceAccessConditionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type BalanceControllerType string

const (
	BalanceControllerTypeHive     BalanceControllerType = "HIVE"
	BalanceControllerTypeDid      BalanceControllerType = "DID"
	BalanceControllerTypeContract BalanceControllerType = "CONTRACT"
)

var AllBalanceControllerType = []BalanceControllerType{
	BalanceControllerTypeHive,
	BalanceControllerTypeDid,
	BalanceControllerTypeContract,
}

func (e BalanceControllerType) IsValid() bool {
	switch e {
	case BalanceControllerTypeHive, BalanceControllerTypeDid, BalanceControllerTypeContract:
		return true
	}
	return false
}

func (e BalanceControllerType) String() string {
	return string(e)
}

func (e *BalanceControllerType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BalanceControllerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BalanceControllerType", str)
	}
	return nil
}

func (e BalanceControllerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionType string

const (
	TransactionTypeNull    TransactionType = "NULL"
	TransactionTypeInput   TransactionType = "INPUT"
	TransactionTypeOutput  TransactionType = "OUTPUT"
	TransactionTypeVirtual TransactionType = "VIRTUAL"
	TransactionTypeCore    TransactionType = "CORE"
)

var AllTransactionType = []TransactionType{
	TransactionTypeNull,
	TransactionTypeInput,
	TransactionTypeOutput,
	TransactionTypeVirtual,
	TransactionTypeCore,
}

func (e TransactionType) IsValid() bool {
	switch e {
	case TransactionTypeNull, TransactionTypeInput, TransactionTypeOutput, TransactionTypeVirtual, TransactionTypeCore:
		return true
	}
	return false
}

func (e TransactionType) String() string {
	return string(e)
}

func (e *TransactionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionType", str)
	}
	return nil
}

func (e TransactionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
