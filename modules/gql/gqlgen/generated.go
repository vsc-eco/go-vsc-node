// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlgen

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
	"vsc-node/modules/db/vsc/contracts"
	"vsc-node/modules/db/vsc/elections"
	ledger_db "vsc-node/modules/db/vsc/ledger"
	"vsc-node/modules/db/vsc/nonces"
	rcDb "vsc-node/modules/db/vsc/rcs"
	"vsc-node/modules/db/vsc/transactions"
	"vsc-node/modules/db/vsc/witnesses"
	"vsc-node/modules/gql/model"
	ledgerSystem "vsc-node/modules/ledger-system"
	state_engine "vsc-node/modules/state-processing"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	ActionRecord() ActionRecordResolver
	BalanceRecord() BalanceRecordResolver
	Contract() ContractResolver
	ContractOutput() ContractOutputResolver
	ElectionResult() ElectionResultResolver
	LedgerRecord() LedgerRecordResolver
	NonceRecord() NonceRecordResolver
	OpLogEvent() OpLogEventResolver
	PostingJsonKeys() PostingJsonKeysResolver
	Query() QueryResolver
	RcRecord() RcRecordResolver
	TransactionOperation() TransactionOperationResolver
	TransactionRecord() TransactionRecordResolver
	Witness() WitnessResolver
	WitnessSlot() WitnessSlotResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	ActionRecord struct {
		ActionID    func(childComplexity int) int
		Amount      func(childComplexity int) int
		Asset       func(childComplexity int) int
		BlockHeight func(childComplexity int) int
		Id          func(childComplexity int) int
		Memo        func(childComplexity int) int
		Params      func(childComplexity int) int
		Status      func(childComplexity int) int
		Timestamp   func(childComplexity int) int
		To          func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	BalanceRecord struct {
		Account             func(childComplexity int) int
		BlockHeight         func(childComplexity int) int
		ConsensusUnstaking  func(childComplexity int) int
		Hbd                 func(childComplexity int) int
		HbdAvg              func(childComplexity int) int
		HbdClaim            func(childComplexity int) int
		HbdModify           func(childComplexity int) int
		HbdSavings          func(childComplexity int) int
		Hive                func(childComplexity int) int
		HiveConsensus       func(childComplexity int) int
		PendingHbdUnstaking func(childComplexity int) int
	}

	Contract struct {
		Code           func(childComplexity int) int
		CreationHeight func(childComplexity int) int
		CreationTs     func(childComplexity int) int
		Creator        func(childComplexity int) int
		Description    func(childComplexity int) int
		Id             func(childComplexity int) int
		Name           func(childComplexity int) int
		Owner          func(childComplexity int) int
		Runtime        func(childComplexity int) int
		TxId           func(childComplexity int) int
	}

	ContractOutput struct {
		BlockHeight func(childComplexity int) int
		ContractId  func(childComplexity int) int
		Id          func(childComplexity int) int
		Inputs      func(childComplexity int) int
		Results     func(childComplexity int) int
		StateMerkle func(childComplexity int) int
		Timestamp   func(childComplexity int) int
	}

	ContractOutputResult struct {
		Ok  func(childComplexity int) int
		Ret func(childComplexity int) int
	}

	ElectionMember struct {
		Account func(childComplexity int) int
		Key     func(childComplexity int) int
	}

	ElectionResult struct {
		BlockHeight     func(childComplexity int) int
		Data            func(childComplexity int) int
		Epoch           func(childComplexity int) int
		Members         func(childComplexity int) int
		NetId           func(childComplexity int) int
		Proposer        func(childComplexity int) int
		ProtocolVersion func(childComplexity int) int
		TotalWeight     func(childComplexity int) int
		TxId            func(childComplexity int) int
		Type            func(childComplexity int) int
		Weights         func(childComplexity int) int
	}

	LedgerAction struct {
		Amount func(childComplexity int) int
		Asset  func(childComplexity int) int
		Data   func(childComplexity int) int
		ID     func(childComplexity int) int
		Memo   func(childComplexity int) int
		Status func(childComplexity int) int
		To     func(childComplexity int) int
		Type   func(childComplexity int) int
	}

	LedgerRecord struct {
		Amount      func(childComplexity int) int
		Asset       func(childComplexity int) int
		BlockHeight func(childComplexity int) int
		From        func(childComplexity int) int
		Id          func(childComplexity int) int
		Owner       func(childComplexity int) int
		Timestamp   func(childComplexity int) int
		TxId        func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	LocalNodeInfo struct {
		Epoch              func(childComplexity int) int
		GitCommit          func(childComplexity int) int
		LastProcessedBlock func(childComplexity int) int
		VersionID          func(childComplexity int) int
	}

	NonceRecord struct {
		Account func(childComplexity int) int
		Nonce   func(childComplexity int) int
	}

	OpLogEvent struct {
		Amount func(childComplexity int) int
		Asset  func(childComplexity int) int
		From   func(childComplexity int) int
		Memo   func(childComplexity int) int
		Params func(childComplexity int) int
		To     func(childComplexity int) int
		Type   func(childComplexity int) int
	}

	PostingJsonKeys struct {
		Ct  func(childComplexity int) int
		Key func(childComplexity int) int
		T   func(childComplexity int) int
	}

	Query struct {
		ElectionByBlockHeight func(childComplexity int, blockHeight *model.Uint64) int
		FindContract          func(childComplexity int, filterOptions *FindContractFilter) int
		FindContractOutput    func(childComplexity int, filterOptions *ContractOutputFilter) int
		FindLedgerActions     func(childComplexity int, filterOptions *LedgerActionsFilter) int
		FindLedgerTXs         func(childComplexity int, filterOptions *LedgerTxFilter) int
		FindTransaction       func(childComplexity int, filterOptions *TransactionFilter) int
		GetAccountBalance     func(childComplexity int, account string, height *model.Uint64) int
		GetAccountNonce       func(childComplexity int, account string) int
		GetAccountRc          func(childComplexity int, account string, height *model.Uint64) int
		GetDagByCid           func(childComplexity int, cidString string) int
		GetElection           func(childComplexity int, epoch model.Uint64) int
		GetStateByKeys        func(childComplexity int, contractID string, keys []string) int
		GetTssKey             func(childComplexity int, keyID string) int
		GetTssRequests        func(childComplexity int, keyID string, msgHex []string) int
		GetWitness            func(childComplexity int, account string, height *model.Uint64) int
		LocalNodeInfo         func(childComplexity int) int
		SubmitTransactionV1   func(childComplexity int, tx string, sig string) int
		WitnessNodes          func(childComplexity int, height model.Uint64) int
		WitnessSchedule       func(childComplexity int, height model.Uint64) int
		WitnessStake          func(childComplexity int, account string) int
	}

	RcRecord struct {
		Account     func(childComplexity int) int
		Amount      func(childComplexity int) int
		BlockHeight func(childComplexity int) int
		MaxRcs      func(childComplexity int) int
	}

	TransactionOperation struct {
		Data          func(childComplexity int) int
		Index         func(childComplexity int) int
		RequiredAuths func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	TransactionOutput struct {
		Id    func(childComplexity int) int
		Index func(childComplexity int) int
	}

	TransactionRecord struct {
		AnchrHeight          func(childComplexity int) int
		AnchrID              func(childComplexity int) int
		AnchrIndex           func(childComplexity int) int
		AnchrTs              func(childComplexity int) int
		FirstSeen            func(childComplexity int) int
		Id                   func(childComplexity int) int
		Ledger               func(childComplexity int) int
		LedgerActions        func(childComplexity int) int
		Nonce                func(childComplexity int) int
		OpTypes              func(childComplexity int) int
		Ops                  func(childComplexity int) int
		Output               func(childComplexity int) int
		RcLimit              func(childComplexity int) int
		RequiredAuths        func(childComplexity int) int
		RequiredPostingAuths func(childComplexity int) int
		Status               func(childComplexity int) int
		Type                 func(childComplexity int) int
	}

	TransactionSubmitResult struct {
		ID func(childComplexity int) int
	}

	TssKey struct {
		Algo          func(childComplexity int) int
		CreatedHeight func(childComplexity int) int
		ID            func(childComplexity int) int
		Owner         func(childComplexity int) int
		PublicKey     func(childComplexity int) int
		Status        func(childComplexity int) int
	}

	TssRequest struct {
		ID     func(childComplexity int) int
		KeyID  func(childComplexity int) int
		Msg    func(childComplexity int) int
		Sig    func(childComplexity int) int
		Status func(childComplexity int) int
	}

	Witness struct {
		Account         func(childComplexity int) int
		DidKeys         func(childComplexity int) int
		Enabled         func(childComplexity int) int
		GatewayKey      func(childComplexity int) int
		GitCommit       func(childComplexity int) int
		Height          func(childComplexity int) int
		NetId           func(childComplexity int) int
		PeerId          func(childComplexity int) int
		ProtocolVersion func(childComplexity int) int
		Ts              func(childComplexity int) int
		TxId            func(childComplexity int) int
		VersionId       func(childComplexity int) int
	}

	WitnessSlot struct {
		Account func(childComplexity int) int
		Bn      func(childComplexity int) int
	}
}

type ActionRecordResolver interface {
	Amount(ctx context.Context, obj *ledger_db.ActionRecord) (model.Int64, error)

	ActionID(ctx context.Context, obj *ledger_db.ActionRecord) (string, error)

	Params(ctx context.Context, obj *ledger_db.ActionRecord) (model.Map, error)
	BlockHeight(ctx context.Context, obj *ledger_db.ActionRecord) (model.Uint64, error)
}
type BalanceRecordResolver interface {
	BlockHeight(ctx context.Context, obj *ledger_db.BalanceRecord) (model.Uint64, error)
	Hbd(ctx context.Context, obj *ledger_db.BalanceRecord) (model.Int64, error)
	HbdAvg(ctx context.Context, obj *ledger_db.BalanceRecord) (model.Int64, error)
	HbdModify(ctx context.Context, obj *ledger_db.BalanceRecord) (model.Uint64, error)
	HbdClaim(ctx context.Context, obj *ledger_db.BalanceRecord) (model.Uint64, error)
	HbdSavings(ctx context.Context, obj *ledger_db.BalanceRecord) (model.Int64, error)
	Hive(ctx context.Context, obj *ledger_db.BalanceRecord) (model.Int64, error)
	HiveConsensus(ctx context.Context, obj *ledger_db.BalanceRecord) (model.Int64, error)
	ConsensusUnstaking(ctx context.Context, obj *ledger_db.BalanceRecord) (model.Int64, error)
	PendingHbdUnstaking(ctx context.Context, obj *ledger_db.BalanceRecord) (*model.Int64, error)
}
type ContractResolver interface {
	CreationHeight(ctx context.Context, obj *contracts.Contract) (model.Uint64, error)

	Runtime(ctx context.Context, obj *contracts.Contract) (string, error)
}
type ContractOutputResolver interface {
	BlockHeight(ctx context.Context, obj *contracts.ContractOutput) (model.Int64, error)
}
type ElectionResultResolver interface {
	Epoch(ctx context.Context, obj *elections.ElectionResult) (model.Uint64, error)

	Weights(ctx context.Context, obj *elections.ElectionResult) ([]model.Uint64, error)
	ProtocolVersion(ctx context.Context, obj *elections.ElectionResult) (model.Uint64, error)
	TotalWeight(ctx context.Context, obj *elections.ElectionResult) (model.Uint64, error)
	BlockHeight(ctx context.Context, obj *elections.ElectionResult) (model.Uint64, error)
}
type LedgerRecordResolver interface {
	Amount(ctx context.Context, obj *ledger_db.LedgerRecord) (model.Int64, error)
	BlockHeight(ctx context.Context, obj *ledger_db.LedgerRecord) (model.Uint64, error)
}
type NonceRecordResolver interface {
	Nonce(ctx context.Context, obj *nonces.NonceRecord) (model.Uint64, error)
}
type OpLogEventResolver interface {
	Amount(ctx context.Context, obj *ledgerSystem.OpLogEvent) (model.Int64, error)

	Params(ctx context.Context, obj *ledgerSystem.OpLogEvent) (model.Map, error)
}
type PostingJsonKeysResolver interface {
	Ct(ctx context.Context, obj *witnesses.PostingJsonKeys) (*string, error)
	T(ctx context.Context, obj *witnesses.PostingJsonKeys) (*string, error)
}
type QueryResolver interface {
	GetStateByKeys(ctx context.Context, contractID string, keys []string) (model.Map, error)
	FindTransaction(ctx context.Context, filterOptions *TransactionFilter) ([]transactions.TransactionRecord, error)
	FindContractOutput(ctx context.Context, filterOptions *ContractOutputFilter) ([]contracts.ContractOutput, error)
	FindLedgerTXs(ctx context.Context, filterOptions *LedgerTxFilter) ([]ledger_db.LedgerRecord, error)
	FindLedgerActions(ctx context.Context, filterOptions *LedgerActionsFilter) ([]ledger_db.ActionRecord, error)
	GetAccountBalance(ctx context.Context, account string, height *model.Uint64) (*ledger_db.BalanceRecord, error)
	GetAccountRc(ctx context.Context, account string, height *model.Uint64) (*rcDb.RcRecord, error)
	FindContract(ctx context.Context, filterOptions *FindContractFilter) ([]contracts.Contract, error)
	SubmitTransactionV1(ctx context.Context, tx string, sig string) (*TransactionSubmitResult, error)
	GetAccountNonce(ctx context.Context, account string) (*nonces.NonceRecord, error)
	LocalNodeInfo(ctx context.Context) (*LocalNodeInfo, error)
	GetWitness(ctx context.Context, account string, height *model.Uint64) (*witnesses.Witness, error)
	WitnessNodes(ctx context.Context, height model.Uint64) ([]witnesses.Witness, error)
	WitnessSchedule(ctx context.Context, height model.Uint64) ([]state_engine.WitnessSlot, error)
	WitnessStake(ctx context.Context, account string) (model.Uint64, error)
	GetDagByCid(ctx context.Context, cidString string) (string, error)
	GetElection(ctx context.Context, epoch model.Uint64) (*elections.ElectionResult, error)
	ElectionByBlockHeight(ctx context.Context, blockHeight *model.Uint64) (*elections.ElectionResult, error)
	GetTssKey(ctx context.Context, keyID string) (*TssKey, error)
	GetTssRequests(ctx context.Context, keyID string, msgHex []string) ([]TssRequest, error)
}
type RcRecordResolver interface {
	Amount(ctx context.Context, obj *rcDb.RcRecord) (model.Int64, error)
	BlockHeight(ctx context.Context, obj *rcDb.RcRecord) (model.Uint64, error)
	MaxRcs(ctx context.Context, obj *rcDb.RcRecord) (model.Int64, error)
}
type TransactionOperationResolver interface {
	Index(ctx context.Context, obj *transactions.TransactionOperation) (model.Uint64, error)
	Data(ctx context.Context, obj *transactions.TransactionOperation) (model.Map, error)
}
type TransactionRecordResolver interface {
	AnchrHeight(ctx context.Context, obj *transactions.TransactionRecord) (model.Uint64, error)
	AnchrIndex(ctx context.Context, obj *transactions.TransactionRecord) (model.Uint64, error)
	AnchrID(ctx context.Context, obj *transactions.TransactionRecord) (*string, error)
	AnchrTs(ctx context.Context, obj *transactions.TransactionRecord) (*string, error)

	Nonce(ctx context.Context, obj *transactions.TransactionRecord) (model.Uint64, error)
	RcLimit(ctx context.Context, obj *transactions.TransactionRecord) (model.Uint64, error)

	LedgerActions(ctx context.Context, obj *transactions.TransactionRecord) ([]*LedgerAction, error)
}
type WitnessResolver interface {
	Height(ctx context.Context, obj *witnesses.Witness) (model.Uint64, error)

	ProtocolVersion(ctx context.Context, obj *witnesses.Witness) (model.Uint64, error)
}
type WitnessSlotResolver interface {
	Bn(ctx context.Context, obj *state_engine.WitnessSlot) (model.Uint64, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "ActionRecord.action_id":
		if e.complexity.ActionRecord.ActionID == nil {
			break
		}

		return e.complexity.ActionRecord.ActionID(childComplexity), true
	case "ActionRecord.amount":
		if e.complexity.ActionRecord.Amount == nil {
			break
		}

		return e.complexity.ActionRecord.Amount(childComplexity), true
	case "ActionRecord.asset":
		if e.complexity.ActionRecord.Asset == nil {
			break
		}

		return e.complexity.ActionRecord.Asset(childComplexity), true
	case "ActionRecord.block_height":
		if e.complexity.ActionRecord.BlockHeight == nil {
			break
		}

		return e.complexity.ActionRecord.BlockHeight(childComplexity), true
	case "ActionRecord.id":
		if e.complexity.ActionRecord.Id == nil {
			break
		}

		return e.complexity.ActionRecord.Id(childComplexity), true
	case "ActionRecord.memo":
		if e.complexity.ActionRecord.Memo == nil {
			break
		}

		return e.complexity.ActionRecord.Memo(childComplexity), true
	case "ActionRecord.params":
		if e.complexity.ActionRecord.Params == nil {
			break
		}

		return e.complexity.ActionRecord.Params(childComplexity), true
	case "ActionRecord.status":
		if e.complexity.ActionRecord.Status == nil {
			break
		}

		return e.complexity.ActionRecord.Status(childComplexity), true
	case "ActionRecord.timestamp":
		if e.complexity.ActionRecord.Timestamp == nil {
			break
		}

		return e.complexity.ActionRecord.Timestamp(childComplexity), true
	case "ActionRecord.to":
		if e.complexity.ActionRecord.To == nil {
			break
		}

		return e.complexity.ActionRecord.To(childComplexity), true
	case "ActionRecord.type":
		if e.complexity.ActionRecord.Type == nil {
			break
		}

		return e.complexity.ActionRecord.Type(childComplexity), true

	case "BalanceRecord.account":
		if e.complexity.BalanceRecord.Account == nil {
			break
		}

		return e.complexity.BalanceRecord.Account(childComplexity), true
	case "BalanceRecord.block_height":
		if e.complexity.BalanceRecord.BlockHeight == nil {
			break
		}

		return e.complexity.BalanceRecord.BlockHeight(childComplexity), true
	case "BalanceRecord.consensus_unstaking":
		if e.complexity.BalanceRecord.ConsensusUnstaking == nil {
			break
		}

		return e.complexity.BalanceRecord.ConsensusUnstaking(childComplexity), true
	case "BalanceRecord.hbd":
		if e.complexity.BalanceRecord.Hbd == nil {
			break
		}

		return e.complexity.BalanceRecord.Hbd(childComplexity), true
	case "BalanceRecord.hbd_avg":
		if e.complexity.BalanceRecord.HbdAvg == nil {
			break
		}

		return e.complexity.BalanceRecord.HbdAvg(childComplexity), true
	case "BalanceRecord.hbd_claim":
		if e.complexity.BalanceRecord.HbdClaim == nil {
			break
		}

		return e.complexity.BalanceRecord.HbdClaim(childComplexity), true
	case "BalanceRecord.hbd_modify":
		if e.complexity.BalanceRecord.HbdModify == nil {
			break
		}

		return e.complexity.BalanceRecord.HbdModify(childComplexity), true
	case "BalanceRecord.hbd_savings":
		if e.complexity.BalanceRecord.HbdSavings == nil {
			break
		}

		return e.complexity.BalanceRecord.HbdSavings(childComplexity), true
	case "BalanceRecord.hive":
		if e.complexity.BalanceRecord.Hive == nil {
			break
		}

		return e.complexity.BalanceRecord.Hive(childComplexity), true
	case "BalanceRecord.hive_consensus":
		if e.complexity.BalanceRecord.HiveConsensus == nil {
			break
		}

		return e.complexity.BalanceRecord.HiveConsensus(childComplexity), true
	case "BalanceRecord.pending_hbd_unstaking":
		if e.complexity.BalanceRecord.PendingHbdUnstaking == nil {
			break
		}

		return e.complexity.BalanceRecord.PendingHbdUnstaking(childComplexity), true

	case "Contract.code":
		if e.complexity.Contract.Code == nil {
			break
		}

		return e.complexity.Contract.Code(childComplexity), true
	case "Contract.creation_height":
		if e.complexity.Contract.CreationHeight == nil {
			break
		}

		return e.complexity.Contract.CreationHeight(childComplexity), true
	case "Contract.creation_ts":
		if e.complexity.Contract.CreationTs == nil {
			break
		}

		return e.complexity.Contract.CreationTs(childComplexity), true
	case "Contract.creator":
		if e.complexity.Contract.Creator == nil {
			break
		}

		return e.complexity.Contract.Creator(childComplexity), true
	case "Contract.description":
		if e.complexity.Contract.Description == nil {
			break
		}

		return e.complexity.Contract.Description(childComplexity), true
	case "Contract.id":
		if e.complexity.Contract.Id == nil {
			break
		}

		return e.complexity.Contract.Id(childComplexity), true
	case "Contract.name":
		if e.complexity.Contract.Name == nil {
			break
		}

		return e.complexity.Contract.Name(childComplexity), true
	case "Contract.owner":
		if e.complexity.Contract.Owner == nil {
			break
		}

		return e.complexity.Contract.Owner(childComplexity), true
	case "Contract.runtime":
		if e.complexity.Contract.Runtime == nil {
			break
		}

		return e.complexity.Contract.Runtime(childComplexity), true
	case "Contract.tx_id":
		if e.complexity.Contract.TxId == nil {
			break
		}

		return e.complexity.Contract.TxId(childComplexity), true

	case "ContractOutput.block_height":
		if e.complexity.ContractOutput.BlockHeight == nil {
			break
		}

		return e.complexity.ContractOutput.BlockHeight(childComplexity), true
	case "ContractOutput.contract_id":
		if e.complexity.ContractOutput.ContractId == nil {
			break
		}

		return e.complexity.ContractOutput.ContractId(childComplexity), true
	case "ContractOutput.id":
		if e.complexity.ContractOutput.Id == nil {
			break
		}

		return e.complexity.ContractOutput.Id(childComplexity), true
	case "ContractOutput.inputs":
		if e.complexity.ContractOutput.Inputs == nil {
			break
		}

		return e.complexity.ContractOutput.Inputs(childComplexity), true
	case "ContractOutput.results":
		if e.complexity.ContractOutput.Results == nil {
			break
		}

		return e.complexity.ContractOutput.Results(childComplexity), true
	case "ContractOutput.state_merkle":
		if e.complexity.ContractOutput.StateMerkle == nil {
			break
		}

		return e.complexity.ContractOutput.StateMerkle(childComplexity), true
	case "ContractOutput.timestamp":
		if e.complexity.ContractOutput.Timestamp == nil {
			break
		}

		return e.complexity.ContractOutput.Timestamp(childComplexity), true

	case "ContractOutputResult.ok":
		if e.complexity.ContractOutputResult.Ok == nil {
			break
		}

		return e.complexity.ContractOutputResult.Ok(childComplexity), true
	case "ContractOutputResult.ret":
		if e.complexity.ContractOutputResult.Ret == nil {
			break
		}

		return e.complexity.ContractOutputResult.Ret(childComplexity), true

	case "ElectionMember.account":
		if e.complexity.ElectionMember.Account == nil {
			break
		}

		return e.complexity.ElectionMember.Account(childComplexity), true
	case "ElectionMember.key":
		if e.complexity.ElectionMember.Key == nil {
			break
		}

		return e.complexity.ElectionMember.Key(childComplexity), true

	case "ElectionResult.block_height":
		if e.complexity.ElectionResult.BlockHeight == nil {
			break
		}

		return e.complexity.ElectionResult.BlockHeight(childComplexity), true
	case "ElectionResult.data":
		if e.complexity.ElectionResult.Data == nil {
			break
		}

		return e.complexity.ElectionResult.Data(childComplexity), true
	case "ElectionResult.epoch":
		if e.complexity.ElectionResult.Epoch == nil {
			break
		}

		return e.complexity.ElectionResult.Epoch(childComplexity), true
	case "ElectionResult.members":
		if e.complexity.ElectionResult.Members == nil {
			break
		}

		return e.complexity.ElectionResult.Members(childComplexity), true
	case "ElectionResult.net_id":
		if e.complexity.ElectionResult.NetId == nil {
			break
		}

		return e.complexity.ElectionResult.NetId(childComplexity), true
	case "ElectionResult.proposer":
		if e.complexity.ElectionResult.Proposer == nil {
			break
		}

		return e.complexity.ElectionResult.Proposer(childComplexity), true
	case "ElectionResult.protocol_version":
		if e.complexity.ElectionResult.ProtocolVersion == nil {
			break
		}

		return e.complexity.ElectionResult.ProtocolVersion(childComplexity), true
	case "ElectionResult.total_weight":
		if e.complexity.ElectionResult.TotalWeight == nil {
			break
		}

		return e.complexity.ElectionResult.TotalWeight(childComplexity), true
	case "ElectionResult.tx_id":
		if e.complexity.ElectionResult.TxId == nil {
			break
		}

		return e.complexity.ElectionResult.TxId(childComplexity), true
	case "ElectionResult.type":
		if e.complexity.ElectionResult.Type == nil {
			break
		}

		return e.complexity.ElectionResult.Type(childComplexity), true
	case "ElectionResult.weights":
		if e.complexity.ElectionResult.Weights == nil {
			break
		}

		return e.complexity.ElectionResult.Weights(childComplexity), true

	case "LedgerAction.amount":
		if e.complexity.LedgerAction.Amount == nil {
			break
		}

		return e.complexity.LedgerAction.Amount(childComplexity), true
	case "LedgerAction.asset":
		if e.complexity.LedgerAction.Asset == nil {
			break
		}

		return e.complexity.LedgerAction.Asset(childComplexity), true
	case "LedgerAction.data":
		if e.complexity.LedgerAction.Data == nil {
			break
		}

		return e.complexity.LedgerAction.Data(childComplexity), true
	case "LedgerAction.id":
		if e.complexity.LedgerAction.ID == nil {
			break
		}

		return e.complexity.LedgerAction.ID(childComplexity), true
	case "LedgerAction.memo":
		if e.complexity.LedgerAction.Memo == nil {
			break
		}

		return e.complexity.LedgerAction.Memo(childComplexity), true
	case "LedgerAction.status":
		if e.complexity.LedgerAction.Status == nil {
			break
		}

		return e.complexity.LedgerAction.Status(childComplexity), true
	case "LedgerAction.to":
		if e.complexity.LedgerAction.To == nil {
			break
		}

		return e.complexity.LedgerAction.To(childComplexity), true
	case "LedgerAction.type":
		if e.complexity.LedgerAction.Type == nil {
			break
		}

		return e.complexity.LedgerAction.Type(childComplexity), true

	case "LedgerRecord.amount":
		if e.complexity.LedgerRecord.Amount == nil {
			break
		}

		return e.complexity.LedgerRecord.Amount(childComplexity), true
	case "LedgerRecord.asset":
		if e.complexity.LedgerRecord.Asset == nil {
			break
		}

		return e.complexity.LedgerRecord.Asset(childComplexity), true
	case "LedgerRecord.block_height":
		if e.complexity.LedgerRecord.BlockHeight == nil {
			break
		}

		return e.complexity.LedgerRecord.BlockHeight(childComplexity), true
	case "LedgerRecord.from":
		if e.complexity.LedgerRecord.From == nil {
			break
		}

		return e.complexity.LedgerRecord.From(childComplexity), true
	case "LedgerRecord.id":
		if e.complexity.LedgerRecord.Id == nil {
			break
		}

		return e.complexity.LedgerRecord.Id(childComplexity), true
	case "LedgerRecord.owner":
		if e.complexity.LedgerRecord.Owner == nil {
			break
		}

		return e.complexity.LedgerRecord.Owner(childComplexity), true
	case "LedgerRecord.timestamp":
		if e.complexity.LedgerRecord.Timestamp == nil {
			break
		}

		return e.complexity.LedgerRecord.Timestamp(childComplexity), true
	case "LedgerRecord.tx_id":
		if e.complexity.LedgerRecord.TxId == nil {
			break
		}

		return e.complexity.LedgerRecord.TxId(childComplexity), true
	case "LedgerRecord.type":
		if e.complexity.LedgerRecord.Type == nil {
			break
		}

		return e.complexity.LedgerRecord.Type(childComplexity), true

	case "LocalNodeInfo.epoch":
		if e.complexity.LocalNodeInfo.Epoch == nil {
			break
		}

		return e.complexity.LocalNodeInfo.Epoch(childComplexity), true
	case "LocalNodeInfo.git_commit":
		if e.complexity.LocalNodeInfo.GitCommit == nil {
			break
		}

		return e.complexity.LocalNodeInfo.GitCommit(childComplexity), true
	case "LocalNodeInfo.last_processed_block":
		if e.complexity.LocalNodeInfo.LastProcessedBlock == nil {
			break
		}

		return e.complexity.LocalNodeInfo.LastProcessedBlock(childComplexity), true
	case "LocalNodeInfo.version_id":
		if e.complexity.LocalNodeInfo.VersionID == nil {
			break
		}

		return e.complexity.LocalNodeInfo.VersionID(childComplexity), true

	case "NonceRecord.account":
		if e.complexity.NonceRecord.Account == nil {
			break
		}

		return e.complexity.NonceRecord.Account(childComplexity), true
	case "NonceRecord.nonce":
		if e.complexity.NonceRecord.Nonce == nil {
			break
		}

		return e.complexity.NonceRecord.Nonce(childComplexity), true

	case "OpLogEvent.amount":
		if e.complexity.OpLogEvent.Amount == nil {
			break
		}

		return e.complexity.OpLogEvent.Amount(childComplexity), true
	case "OpLogEvent.asset":
		if e.complexity.OpLogEvent.Asset == nil {
			break
		}

		return e.complexity.OpLogEvent.Asset(childComplexity), true
	case "OpLogEvent.from":
		if e.complexity.OpLogEvent.From == nil {
			break
		}

		return e.complexity.OpLogEvent.From(childComplexity), true
	case "OpLogEvent.memo":
		if e.complexity.OpLogEvent.Memo == nil {
			break
		}

		return e.complexity.OpLogEvent.Memo(childComplexity), true
	case "OpLogEvent.params":
		if e.complexity.OpLogEvent.Params == nil {
			break
		}

		return e.complexity.OpLogEvent.Params(childComplexity), true
	case "OpLogEvent.to":
		if e.complexity.OpLogEvent.To == nil {
			break
		}

		return e.complexity.OpLogEvent.To(childComplexity), true
	case "OpLogEvent.type":
		if e.complexity.OpLogEvent.Type == nil {
			break
		}

		return e.complexity.OpLogEvent.Type(childComplexity), true

	case "PostingJsonKeys.ct":
		if e.complexity.PostingJsonKeys.Ct == nil {
			break
		}

		return e.complexity.PostingJsonKeys.Ct(childComplexity), true
	case "PostingJsonKeys.key":
		if e.complexity.PostingJsonKeys.Key == nil {
			break
		}

		return e.complexity.PostingJsonKeys.Key(childComplexity), true
	case "PostingJsonKeys.t":
		if e.complexity.PostingJsonKeys.T == nil {
			break
		}

		return e.complexity.PostingJsonKeys.T(childComplexity), true

	case "Query.electionByBlockHeight":
		if e.complexity.Query.ElectionByBlockHeight == nil {
			break
		}

		args, err := ec.field_Query_electionByBlockHeight_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ElectionByBlockHeight(childComplexity, args["blockHeight"].(*model.Uint64)), true
	case "Query.findContract":
		if e.complexity.Query.FindContract == nil {
			break
		}

		args, err := ec.field_Query_findContract_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindContract(childComplexity, args["filterOptions"].(*FindContractFilter)), true
	case "Query.findContractOutput":
		if e.complexity.Query.FindContractOutput == nil {
			break
		}

		args, err := ec.field_Query_findContractOutput_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindContractOutput(childComplexity, args["filterOptions"].(*ContractOutputFilter)), true
	case "Query.findLedgerActions":
		if e.complexity.Query.FindLedgerActions == nil {
			break
		}

		args, err := ec.field_Query_findLedgerActions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindLedgerActions(childComplexity, args["filterOptions"].(*LedgerActionsFilter)), true
	case "Query.findLedgerTXs":
		if e.complexity.Query.FindLedgerTXs == nil {
			break
		}

		args, err := ec.field_Query_findLedgerTXs_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindLedgerTXs(childComplexity, args["filterOptions"].(*LedgerTxFilter)), true
	case "Query.findTransaction":
		if e.complexity.Query.FindTransaction == nil {
			break
		}

		args, err := ec.field_Query_findTransaction_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindTransaction(childComplexity, args["filterOptions"].(*TransactionFilter)), true
	case "Query.getAccountBalance":
		if e.complexity.Query.GetAccountBalance == nil {
			break
		}

		args, err := ec.field_Query_getAccountBalance_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAccountBalance(childComplexity, args["account"].(string), args["height"].(*model.Uint64)), true
	case "Query.getAccountNonce":
		if e.complexity.Query.GetAccountNonce == nil {
			break
		}

		args, err := ec.field_Query_getAccountNonce_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAccountNonce(childComplexity, args["account"].(string)), true
	case "Query.getAccountRC":
		if e.complexity.Query.GetAccountRc == nil {
			break
		}

		args, err := ec.field_Query_getAccountRC_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAccountRc(childComplexity, args["account"].(string), args["height"].(*model.Uint64)), true
	case "Query.getDagByCID":
		if e.complexity.Query.GetDagByCid == nil {
			break
		}

		args, err := ec.field_Query_getDagByCID_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetDagByCid(childComplexity, args["cidString"].(string)), true
	case "Query.getElection":
		if e.complexity.Query.GetElection == nil {
			break
		}

		args, err := ec.field_Query_getElection_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetElection(childComplexity, args["epoch"].(model.Uint64)), true
	case "Query.getStateByKeys":
		if e.complexity.Query.GetStateByKeys == nil {
			break
		}

		args, err := ec.field_Query_getStateByKeys_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetStateByKeys(childComplexity, args["contractId"].(string), args["keys"].([]string)), true
	case "Query.getTssKey":
		if e.complexity.Query.GetTssKey == nil {
			break
		}

		args, err := ec.field_Query_getTssKey_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTssKey(childComplexity, args["keyId"].(string)), true
	case "Query.getTssRequests":
		if e.complexity.Query.GetTssRequests == nil {
			break
		}

		args, err := ec.field_Query_getTssRequests_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTssRequests(childComplexity, args["keyId"].(string), args["msgHex"].([]string)), true
	case "Query.getWitness":
		if e.complexity.Query.GetWitness == nil {
			break
		}

		args, err := ec.field_Query_getWitness_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetWitness(childComplexity, args["account"].(string), args["height"].(*model.Uint64)), true
	case "Query.localNodeInfo":
		if e.complexity.Query.LocalNodeInfo == nil {
			break
		}

		return e.complexity.Query.LocalNodeInfo(childComplexity), true
	case "Query.submitTransactionV1":
		if e.complexity.Query.SubmitTransactionV1 == nil {
			break
		}

		args, err := ec.field_Query_submitTransactionV1_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SubmitTransactionV1(childComplexity, args["tx"].(string), args["sig"].(string)), true
	case "Query.witnessNodes":
		if e.complexity.Query.WitnessNodes == nil {
			break
		}

		args, err := ec.field_Query_witnessNodes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WitnessNodes(childComplexity, args["height"].(model.Uint64)), true
	case "Query.witnessSchedule":
		if e.complexity.Query.WitnessSchedule == nil {
			break
		}

		args, err := ec.field_Query_witnessSchedule_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WitnessSchedule(childComplexity, args["height"].(model.Uint64)), true
	case "Query.witnessStake":
		if e.complexity.Query.WitnessStake == nil {
			break
		}

		args, err := ec.field_Query_witnessStake_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WitnessStake(childComplexity, args["account"].(string)), true

	case "RcRecord.account":
		if e.complexity.RcRecord.Account == nil {
			break
		}

		return e.complexity.RcRecord.Account(childComplexity), true
	case "RcRecord.amount":
		if e.complexity.RcRecord.Amount == nil {
			break
		}

		return e.complexity.RcRecord.Amount(childComplexity), true
	case "RcRecord.block_height":
		if e.complexity.RcRecord.BlockHeight == nil {
			break
		}

		return e.complexity.RcRecord.BlockHeight(childComplexity), true
	case "RcRecord.max_rcs":
		if e.complexity.RcRecord.MaxRcs == nil {
			break
		}

		return e.complexity.RcRecord.MaxRcs(childComplexity), true

	case "TransactionOperation.data":
		if e.complexity.TransactionOperation.Data == nil {
			break
		}

		return e.complexity.TransactionOperation.Data(childComplexity), true
	case "TransactionOperation.index":
		if e.complexity.TransactionOperation.Index == nil {
			break
		}

		return e.complexity.TransactionOperation.Index(childComplexity), true
	case "TransactionOperation.required_auths":
		if e.complexity.TransactionOperation.RequiredAuths == nil {
			break
		}

		return e.complexity.TransactionOperation.RequiredAuths(childComplexity), true
	case "TransactionOperation.type":
		if e.complexity.TransactionOperation.Type == nil {
			break
		}

		return e.complexity.TransactionOperation.Type(childComplexity), true

	case "TransactionOutput.id":
		if e.complexity.TransactionOutput.Id == nil {
			break
		}

		return e.complexity.TransactionOutput.Id(childComplexity), true
	case "TransactionOutput.index":
		if e.complexity.TransactionOutput.Index == nil {
			break
		}

		return e.complexity.TransactionOutput.Index(childComplexity), true

	case "TransactionRecord.anchr_height":
		if e.complexity.TransactionRecord.AnchrHeight == nil {
			break
		}

		return e.complexity.TransactionRecord.AnchrHeight(childComplexity), true
	case "TransactionRecord.anchr_id":
		if e.complexity.TransactionRecord.AnchrID == nil {
			break
		}

		return e.complexity.TransactionRecord.AnchrID(childComplexity), true
	case "TransactionRecord.anchr_index":
		if e.complexity.TransactionRecord.AnchrIndex == nil {
			break
		}

		return e.complexity.TransactionRecord.AnchrIndex(childComplexity), true
	case "TransactionRecord.anchr_ts":
		if e.complexity.TransactionRecord.AnchrTs == nil {
			break
		}

		return e.complexity.TransactionRecord.AnchrTs(childComplexity), true
	case "TransactionRecord.first_seen":
		if e.complexity.TransactionRecord.FirstSeen == nil {
			break
		}

		return e.complexity.TransactionRecord.FirstSeen(childComplexity), true
	case "TransactionRecord.id":
		if e.complexity.TransactionRecord.Id == nil {
			break
		}

		return e.complexity.TransactionRecord.Id(childComplexity), true
	case "TransactionRecord.ledger":
		if e.complexity.TransactionRecord.Ledger == nil {
			break
		}

		return e.complexity.TransactionRecord.Ledger(childComplexity), true
	case "TransactionRecord.ledger_actions":
		if e.complexity.TransactionRecord.LedgerActions == nil {
			break
		}

		return e.complexity.TransactionRecord.LedgerActions(childComplexity), true
	case "TransactionRecord.nonce":
		if e.complexity.TransactionRecord.Nonce == nil {
			break
		}

		return e.complexity.TransactionRecord.Nonce(childComplexity), true
	case "TransactionRecord.op_types":
		if e.complexity.TransactionRecord.OpTypes == nil {
			break
		}

		return e.complexity.TransactionRecord.OpTypes(childComplexity), true
	case "TransactionRecord.ops":
		if e.complexity.TransactionRecord.Ops == nil {
			break
		}

		return e.complexity.TransactionRecord.Ops(childComplexity), true
	case "TransactionRecord.output":
		if e.complexity.TransactionRecord.Output == nil {
			break
		}

		return e.complexity.TransactionRecord.Output(childComplexity), true
	case "TransactionRecord.rc_limit":
		if e.complexity.TransactionRecord.RcLimit == nil {
			break
		}

		return e.complexity.TransactionRecord.RcLimit(childComplexity), true
	case "TransactionRecord.required_auths":
		if e.complexity.TransactionRecord.RequiredAuths == nil {
			break
		}

		return e.complexity.TransactionRecord.RequiredAuths(childComplexity), true
	case "TransactionRecord.required_posting_auths":
		if e.complexity.TransactionRecord.RequiredPostingAuths == nil {
			break
		}

		return e.complexity.TransactionRecord.RequiredPostingAuths(childComplexity), true
	case "TransactionRecord.status":
		if e.complexity.TransactionRecord.Status == nil {
			break
		}

		return e.complexity.TransactionRecord.Status(childComplexity), true
	case "TransactionRecord.type":
		if e.complexity.TransactionRecord.Type == nil {
			break
		}

		return e.complexity.TransactionRecord.Type(childComplexity), true

	case "TransactionSubmitResult.id":
		if e.complexity.TransactionSubmitResult.ID == nil {
			break
		}

		return e.complexity.TransactionSubmitResult.ID(childComplexity), true

	case "TssKey.Algo":
		if e.complexity.TssKey.Algo == nil {
			break
		}

		return e.complexity.TssKey.Algo(childComplexity), true
	case "TssKey.CreatedHeight":
		if e.complexity.TssKey.CreatedHeight == nil {
			break
		}

		return e.complexity.TssKey.CreatedHeight(childComplexity), true
	case "TssKey.id":
		if e.complexity.TssKey.ID == nil {
			break
		}

		return e.complexity.TssKey.ID(childComplexity), true
	case "TssKey.Owner":
		if e.complexity.TssKey.Owner == nil {
			break
		}

		return e.complexity.TssKey.Owner(childComplexity), true
	case "TssKey.PublicKey":
		if e.complexity.TssKey.PublicKey == nil {
			break
		}

		return e.complexity.TssKey.PublicKey(childComplexity), true
	case "TssKey.status":
		if e.complexity.TssKey.Status == nil {
			break
		}

		return e.complexity.TssKey.Status(childComplexity), true

	case "TssRequest.id":
		if e.complexity.TssRequest.ID == nil {
			break
		}

		return e.complexity.TssRequest.ID(childComplexity), true
	case "TssRequest.keyId":
		if e.complexity.TssRequest.KeyID == nil {
			break
		}

		return e.complexity.TssRequest.KeyID(childComplexity), true
	case "TssRequest.msg":
		if e.complexity.TssRequest.Msg == nil {
			break
		}

		return e.complexity.TssRequest.Msg(childComplexity), true
	case "TssRequest.sig":
		if e.complexity.TssRequest.Sig == nil {
			break
		}

		return e.complexity.TssRequest.Sig(childComplexity), true
	case "TssRequest.status":
		if e.complexity.TssRequest.Status == nil {
			break
		}

		return e.complexity.TssRequest.Status(childComplexity), true

	case "Witness.account":
		if e.complexity.Witness.Account == nil {
			break
		}

		return e.complexity.Witness.Account(childComplexity), true
	case "Witness.did_keys":
		if e.complexity.Witness.DidKeys == nil {
			break
		}

		return e.complexity.Witness.DidKeys(childComplexity), true
	case "Witness.enabled":
		if e.complexity.Witness.Enabled == nil {
			break
		}

		return e.complexity.Witness.Enabled(childComplexity), true
	case "Witness.gateway_key":
		if e.complexity.Witness.GatewayKey == nil {
			break
		}

		return e.complexity.Witness.GatewayKey(childComplexity), true
	case "Witness.git_commit":
		if e.complexity.Witness.GitCommit == nil {
			break
		}

		return e.complexity.Witness.GitCommit(childComplexity), true
	case "Witness.height":
		if e.complexity.Witness.Height == nil {
			break
		}

		return e.complexity.Witness.Height(childComplexity), true
	case "Witness.net_id":
		if e.complexity.Witness.NetId == nil {
			break
		}

		return e.complexity.Witness.NetId(childComplexity), true
	case "Witness.peer_id":
		if e.complexity.Witness.PeerId == nil {
			break
		}

		return e.complexity.Witness.PeerId(childComplexity), true
	case "Witness.protocol_version":
		if e.complexity.Witness.ProtocolVersion == nil {
			break
		}

		return e.complexity.Witness.ProtocolVersion(childComplexity), true
	case "Witness.ts":
		if e.complexity.Witness.Ts == nil {
			break
		}

		return e.complexity.Witness.Ts(childComplexity), true
	case "Witness.tx_id":
		if e.complexity.Witness.TxId == nil {
			break
		}

		return e.complexity.Witness.TxId(childComplexity), true
	case "Witness.version_id":
		if e.complexity.Witness.VersionId == nil {
			break
		}

		return e.complexity.Witness.VersionId(childComplexity), true

	case "WitnessSlot.account":
		if e.complexity.WitnessSlot.Account == nil {
			break
		}

		return e.complexity.WitnessSlot.Account(childComplexity), true
	case "WitnessSlot.bn":
		if e.complexity.WitnessSlot.Bn == nil {
			break
		}

		return e.complexity.WitnessSlot.Bn(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputContractOutputFilter,
		ec.unmarshalInputFindContractFilter,
		ec.unmarshalInputLedgerActionsFilter,
		ec.unmarshalInputLedgerTxFilter,
		ec.unmarshalInputTransactionFilter,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphql", Input: `scalar JSON

enum TransactionStatus {
  UNCONFIRMED
  CONFIRMED
  FAILED
  INCLUDED
  PROCESSED
}

enum Asset {
  hive
  hive_consensus
  hbd
  hbd_savings
}

type TransactionRecord {
  id: String!
  anchr_height: Uint64!
  anchr_index: Uint64!
  anchr_id: String
  anchr_ts: String
  type: String!
  ops: [TransactionOperation]
  op_types: [String!]
  first_seen: DateTime!
  nonce: Uint64!
  rc_limit: Uint64!
  required_auths: [String!]
  required_posting_auths: [String!]
  status: String!
  ledger: [OpLogEvent!]
  ledger_actions: [LedgerAction]
  output: [TransactionOutput!]
}

type TransactionOperation {
  required_auths: [String!]
  type: String
  index: Uint64!
  data: Map
}

type LedgerAction {
  id: String
  status: String
  type: String
  data: Map
  asset: String
  amount: Uint64
  memo: String
  to: String
}

type OpLogEvent {
  to: String!
  from: String!
  amount: Int64!
  asset: String!
  memo: String
  type: String!
  params: Map
}

type TransactionOutput {
  index: [Int!]
  id: String!
}

type ContractOutputResult {
  ret: String!
  ok: Boolean!
}

type ContractOutput {
  id: String!
  block_height: Int64!
  timestamp: String!
  contract_id: String!
  inputs: [String!]!
  state_merkle: String!
  results: [ContractOutputResult!]!
}

type Contract {
  id: String!
  code: String
  name: String
  description: String
  creator: String
  owner: String
  tx_id: String
  creation_height: Uint64!
  creation_ts: String!
  runtime: String!
}

type TransactionSubmitResult {
  id: String
}

type NonceRecord {
  account: String!
  nonce: Uint64!
}

type LocalNodeInfo {
  version_id: String!
  git_commit: String!
  last_processed_block: Uint64!
  epoch: Uint64!
}

type PostingJsonKeys {
  ct: String
  t: String
  key: String
}

type Witness {
  account: String
  height: Uint64!
  did_keys: [PostingJsonKeys!]!
  enabled: Boolean
  git_commit: String
  net_id: String
  peer_id: String
  protocol_version: Uint64!
  ts: String
  tx_id: String
  version_id: String
  gateway_key: String
}

type WitnessSlot {
  account: String
  bn: Uint64!
}

type BalanceRecord {
  account: String
  block_height: Uint64!
  hbd: Int64!
  hbd_avg: Int64!
  hbd_modify: Uint64!
  hbd_claim: Uint64!
  hbd_savings: Int64!
  hive: Int64!
  hive_consensus: Int64!
  consensus_unstaking: Int64!
  pending_hbd_unstaking: Int64
}

type RcRecord {
  account: String!
  amount: Int64!
  block_height: Uint64!
  max_rcs: Int64!
}

type LedgerRecord {
  id: String!
  amount: Int64!
  block_height: Uint64!
  timestamp: String!
  from: String!
  owner: String!
  type: String!
  asset: String!
  tx_id: String!
}

type ActionRecord {
  id: String!
  status: String!
  amount: Int64!
  asset: String!
  to: String!
  memo: String!
  action_id: String!
  type: String!
  params: Map
  block_height: Uint64!
  timestamp: String!
}

type ElectionMember {
  key: String!
  account: String!
}

type ElectionResult {
  epoch: Uint64!
  net_id: String!
  type: String!
  data: String!
  members: [ElectionMember!]!
  weights: [Uint64!]!
  protocol_version: Uint64!
  total_weight: Uint64!
  block_height: Uint64!
  proposer: String!
  tx_id: String!
}

type TssKey {
	id: String!
	status: String!
	PublicKey: String!
	Owner: String!
	Algo: String!
	CreatedHeight: Int!
}

type TssRequest {
	id: String!
	status: String!
	keyId: String!
	msg: String!  
	sig: String! 
}

input LedgerTxFilter {
  byToFrom: String
  byTxId: String
  byTypes: [String!]
  byAsset: Asset
  fromBlock: Uint64
  toBlock: Uint64
  offset: Int
  limit: Int
}

input LedgerActionsFilter {
  byTxId: String
  byActionId: String
  byAccount: String
  byTypes: [String!]
  byAsset: Asset
  byStatus: String
  fromBlock: Uint64
  toBlock: Uint64
  offset: Int
  limit: Int
}

input TransactionFilter {
  byId: String
  byIds: [String!]
  byAccount: String
  byContract: String
  byStatus: TransactionStatus
  byType: [String!]
  byLedgerToFrom: String
  byLedgerTypes: [String!]
  fromBlock: Uint64
  toBlock: Uint64
  offset: Int
  limit: Int
}

input FindContractFilter {
  byId: String
  byCode: String
  historical: Boolean
  offset: Int
  limit: Int
}

input ContractOutputFilter {
  byId: String
  byInput: String
  byContract: String
  fromBlock: Uint64
  toBlock: Uint64
  offset: Int
  limit: Int
}

type Query {
  getStateByKeys(contractId: String!, keys: [String!]!): Map
  findTransaction(filterOptions: TransactionFilter): [TransactionRecord!]
  findContractOutput(filterOptions: ContractOutputFilter): [ContractOutput!]
  findLedgerTXs(filterOptions: LedgerTxFilter): [LedgerRecord!]
  findLedgerActions(filterOptions: LedgerActionsFilter): [ActionRecord!]
  getAccountBalance(account: String!, height: Uint64): BalanceRecord
  getAccountRC(account: String!, height: Uint64): RcRecord
  findContract(filterOptions: FindContractFilter): [Contract!]
  submitTransactionV1(tx: String!, sig: String!): TransactionSubmitResult
  getAccountNonce(account: String!): NonceRecord
  localNodeInfo: LocalNodeInfo
  getWitness(account: String!, height: Uint64): Witness
  witnessNodes(height: Uint64!): [Witness!]!
  witnessSchedule(height: Uint64!): [WitnessSlot!]!
  witnessStake(account: String!): Uint64!
  getDagByCID(cidString: String!): JSON!
  getElection(epoch: Uint64!): ElectionResult
  electionByBlockHeight(blockHeight: Uint64): ElectionResult!
  getTssKey(keyId: String!): TssKey
  getTssRequests(keyId: String!, msgHex: [String!]): [TssRequest!]
}

scalar Uint64
scalar Int64
scalar Map
scalar DateTime
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "name", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_electionByBlockHeight_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "blockHeight", ec.unmarshalOUint642vscnodemodulesgqlmodelUint64)
	if err != nil {
		return nil, err
	}
	args["blockHeight"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findContractOutput_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "filterOptions", ec.unmarshalOContractOutputFilter2vscnodemodulesgqlgqlgenContractOutputFilter)
	if err != nil {
		return nil, err
	}
	args["filterOptions"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findContract_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "filterOptions", ec.unmarshalOFindContractFilter2vscnodemodulesgqlgqlgenFindContractFilter)
	if err != nil {
		return nil, err
	}
	args["filterOptions"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findLedgerActions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "filterOptions", ec.unmarshalOLedgerActionsFilter2vscnodemodulesgqlgqlgenLedgerActionsFilter)
	if err != nil {
		return nil, err
	}
	args["filterOptions"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findLedgerTXs_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "filterOptions", ec.unmarshalOLedgerTxFilter2vscnodemodulesgqlgqlgenLedgerTxFilter)
	if err != nil {
		return nil, err
	}
	args["filterOptions"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_findTransaction_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "filterOptions", ec.unmarshalOTransactionFilter2vscnodemodulesgqlgqlgenTransactionFilter)
	if err != nil {
		return nil, err
	}
	args["filterOptions"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getAccountBalance_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "account", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["account"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "height", ec.unmarshalOUint642vscnodemodulesgqlmodelUint64)
	if err != nil {
		return nil, err
	}
	args["height"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getAccountNonce_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "account", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["account"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getAccountRC_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "account", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["account"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "height", ec.unmarshalOUint642vscnodemodulesgqlmodelUint64)
	if err != nil {
		return nil, err
	}
	args["height"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getDagByCID_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "cidString", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["cidString"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getElection_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "epoch", ec.unmarshalNUint642vscnodemodulesgqlmodelUint64)
	if err != nil {
		return nil, err
	}
	args["epoch"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getStateByKeys_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "contractId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["contractId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "keys", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["keys"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getTssKey_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "keyId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["keyId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getTssRequests_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "keyId", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["keyId"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "msgHex", ec.unmarshalOString2string)
	if err != nil {
		return nil, err
	}
	args["msgHex"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getWitness_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "account", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["account"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "height", ec.unmarshalOUint642vscnodemodulesgqlmodelUint64)
	if err != nil {
		return nil, err
	}
	args["height"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_submitTransactionV1_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "tx", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["tx"] = arg0
	arg1, err := graphql.ProcessArgField(ctx, rawArgs, "sig", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["sig"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_witnessNodes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "height", ec.unmarshalNUint642vscnodemodulesgqlmodelUint64)
	if err != nil {
		return nil, err
	}
	args["height"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_witnessSchedule_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "height", ec.unmarshalNUint642vscnodemodulesgqlmodelUint64)
	if err != nil {
		return nil, err
	}
	args["height"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_witnessStake_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "account", ec.unmarshalNString2string)
	if err != nil {
		return nil, err
	}
	args["account"] = arg0
	return args, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := graphql.ProcessArgField(ctx, rawArgs, "includeDeprecated", ec.unmarshalOBoolean2bool)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ActionRecord_id(ctx context.Context, field graphql.CollectedField, obj *ledger_db.ActionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ActionRecord_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ActionRecord_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionRecord_status(ctx context.Context, field graphql.CollectedField, obj *ledger_db.ActionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ActionRecord_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ActionRecord_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionRecord_amount(ctx context.Context, field graphql.CollectedField, obj *ledger_db.ActionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ActionRecord_amount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ActionRecord().Amount(ctx, obj)
		},
		nil,
		ec.marshalNInt642vscnodemodulesgqlmodelInt64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ActionRecord_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionRecord_asset(ctx context.Context, field graphql.CollectedField, obj *ledger_db.ActionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ActionRecord_asset,
		func(ctx context.Context) (any, error) {
			return obj.Asset, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ActionRecord_asset(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionRecord_to(ctx context.Context, field graphql.CollectedField, obj *ledger_db.ActionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ActionRecord_to,
		func(ctx context.Context) (any, error) {
			return obj.To, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ActionRecord_to(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionRecord_memo(ctx context.Context, field graphql.CollectedField, obj *ledger_db.ActionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ActionRecord_memo,
		func(ctx context.Context) (any, error) {
			return obj.Memo, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ActionRecord_memo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionRecord_action_id(ctx context.Context, field graphql.CollectedField, obj *ledger_db.ActionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ActionRecord_action_id,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ActionRecord().ActionID(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ActionRecord_action_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionRecord_type(ctx context.Context, field graphql.CollectedField, obj *ledger_db.ActionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ActionRecord_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ActionRecord_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionRecord_params(ctx context.Context, field graphql.CollectedField, obj *ledger_db.ActionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ActionRecord_params,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ActionRecord().Params(ctx, obj)
		},
		nil,
		ec.marshalOMap2vscnodemodulesgqlmodelMap,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ActionRecord_params(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionRecord_block_height(ctx context.Context, field graphql.CollectedField, obj *ledger_db.ActionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ActionRecord_block_height,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ActionRecord().BlockHeight(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ActionRecord_block_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ActionRecord_timestamp(ctx context.Context, field graphql.CollectedField, obj *ledger_db.ActionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ActionRecord_timestamp,
		func(ctx context.Context) (any, error) {
			return obj.Timestamp, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ActionRecord_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ActionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BalanceRecord_account(ctx context.Context, field graphql.CollectedField, obj *ledger_db.BalanceRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BalanceRecord_account,
		func(ctx context.Context) (any, error) {
			return obj.Account, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BalanceRecord_account(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BalanceRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BalanceRecord_block_height(ctx context.Context, field graphql.CollectedField, obj *ledger_db.BalanceRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BalanceRecord_block_height,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.BalanceRecord().BlockHeight(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BalanceRecord_block_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BalanceRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BalanceRecord_hbd(ctx context.Context, field graphql.CollectedField, obj *ledger_db.BalanceRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BalanceRecord_hbd,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.BalanceRecord().Hbd(ctx, obj)
		},
		nil,
		ec.marshalNInt642vscnodemodulesgqlmodelInt64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BalanceRecord_hbd(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BalanceRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BalanceRecord_hbd_avg(ctx context.Context, field graphql.CollectedField, obj *ledger_db.BalanceRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BalanceRecord_hbd_avg,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.BalanceRecord().HbdAvg(ctx, obj)
		},
		nil,
		ec.marshalNInt642vscnodemodulesgqlmodelInt64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BalanceRecord_hbd_avg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BalanceRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BalanceRecord_hbd_modify(ctx context.Context, field graphql.CollectedField, obj *ledger_db.BalanceRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BalanceRecord_hbd_modify,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.BalanceRecord().HbdModify(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BalanceRecord_hbd_modify(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BalanceRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BalanceRecord_hbd_claim(ctx context.Context, field graphql.CollectedField, obj *ledger_db.BalanceRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BalanceRecord_hbd_claim,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.BalanceRecord().HbdClaim(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BalanceRecord_hbd_claim(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BalanceRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BalanceRecord_hbd_savings(ctx context.Context, field graphql.CollectedField, obj *ledger_db.BalanceRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BalanceRecord_hbd_savings,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.BalanceRecord().HbdSavings(ctx, obj)
		},
		nil,
		ec.marshalNInt642vscnodemodulesgqlmodelInt64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BalanceRecord_hbd_savings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BalanceRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BalanceRecord_hive(ctx context.Context, field graphql.CollectedField, obj *ledger_db.BalanceRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BalanceRecord_hive,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.BalanceRecord().Hive(ctx, obj)
		},
		nil,
		ec.marshalNInt642vscnodemodulesgqlmodelInt64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BalanceRecord_hive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BalanceRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BalanceRecord_hive_consensus(ctx context.Context, field graphql.CollectedField, obj *ledger_db.BalanceRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BalanceRecord_hive_consensus,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.BalanceRecord().HiveConsensus(ctx, obj)
		},
		nil,
		ec.marshalNInt642vscnodemodulesgqlmodelInt64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BalanceRecord_hive_consensus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BalanceRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BalanceRecord_consensus_unstaking(ctx context.Context, field graphql.CollectedField, obj *ledger_db.BalanceRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BalanceRecord_consensus_unstaking,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.BalanceRecord().ConsensusUnstaking(ctx, obj)
		},
		nil,
		ec.marshalNInt642vscnodemodulesgqlmodelInt64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BalanceRecord_consensus_unstaking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BalanceRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BalanceRecord_pending_hbd_unstaking(ctx context.Context, field graphql.CollectedField, obj *ledger_db.BalanceRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BalanceRecord_pending_hbd_unstaking,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.BalanceRecord().PendingHbdUnstaking(ctx, obj)
		},
		nil,
		ec.marshalOInt642vscnodemodulesgqlmodelInt64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BalanceRecord_pending_hbd_unstaking(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BalanceRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_id(ctx context.Context, field graphql.CollectedField, obj *contracts.Contract) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Contract_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Contract_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_code(ctx context.Context, field graphql.CollectedField, obj *contracts.Contract) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Contract_code,
		func(ctx context.Context) (any, error) {
			return obj.Code, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Contract_code(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_name(ctx context.Context, field graphql.CollectedField, obj *contracts.Contract) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Contract_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Contract_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_description(ctx context.Context, field graphql.CollectedField, obj *contracts.Contract) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Contract_description,
		func(ctx context.Context) (any, error) {
			return obj.Description, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Contract_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_creator(ctx context.Context, field graphql.CollectedField, obj *contracts.Contract) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Contract_creator,
		func(ctx context.Context) (any, error) {
			return obj.Creator, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Contract_creator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_owner(ctx context.Context, field graphql.CollectedField, obj *contracts.Contract) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Contract_owner,
		func(ctx context.Context) (any, error) {
			return obj.Owner, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Contract_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_tx_id(ctx context.Context, field graphql.CollectedField, obj *contracts.Contract) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Contract_tx_id,
		func(ctx context.Context) (any, error) {
			return obj.TxId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Contract_tx_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_creation_height(ctx context.Context, field graphql.CollectedField, obj *contracts.Contract) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Contract_creation_height,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Contract().CreationHeight(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Contract_creation_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_creation_ts(ctx context.Context, field graphql.CollectedField, obj *contracts.Contract) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Contract_creation_ts,
		func(ctx context.Context) (any, error) {
			return obj.CreationTs, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Contract_creation_ts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Contract_runtime(ctx context.Context, field graphql.CollectedField, obj *contracts.Contract) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Contract_runtime,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Contract().Runtime(ctx, obj)
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Contract_runtime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Contract",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContractOutput_id(ctx context.Context, field graphql.CollectedField, obj *contracts.ContractOutput) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContractOutput_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContractOutput_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContractOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContractOutput_block_height(ctx context.Context, field graphql.CollectedField, obj *contracts.ContractOutput) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContractOutput_block_height,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ContractOutput().BlockHeight(ctx, obj)
		},
		nil,
		ec.marshalNInt642vscnodemodulesgqlmodelInt64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContractOutput_block_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContractOutput",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContractOutput_timestamp(ctx context.Context, field graphql.CollectedField, obj *contracts.ContractOutput) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContractOutput_timestamp,
		func(ctx context.Context) (any, error) {
			return obj.Timestamp, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContractOutput_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContractOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContractOutput_contract_id(ctx context.Context, field graphql.CollectedField, obj *contracts.ContractOutput) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContractOutput_contract_id,
		func(ctx context.Context) (any, error) {
			return obj.ContractId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContractOutput_contract_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContractOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContractOutput_inputs(ctx context.Context, field graphql.CollectedField, obj *contracts.ContractOutput) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContractOutput_inputs,
		func(ctx context.Context) (any, error) {
			return obj.Inputs, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContractOutput_inputs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContractOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContractOutput_state_merkle(ctx context.Context, field graphql.CollectedField, obj *contracts.ContractOutput) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContractOutput_state_merkle,
		func(ctx context.Context) (any, error) {
			return obj.StateMerkle, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContractOutput_state_merkle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContractOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContractOutput_results(ctx context.Context, field graphql.CollectedField, obj *contracts.ContractOutput) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContractOutput_results,
		func(ctx context.Context) (any, error) {
			return obj.Results, nil
		},
		nil,
		ec.marshalNContractOutputResult2vscnodemodulesdbvsccontractsContractOutputResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContractOutput_results(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContractOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ret":
				return ec.fieldContext_ContractOutputResult_ret(ctx, field)
			case "ok":
				return ec.fieldContext_ContractOutputResult_ok(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContractOutputResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContractOutputResult_ret(ctx context.Context, field graphql.CollectedField, obj *contracts.ContractOutputResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContractOutputResult_ret,
		func(ctx context.Context) (any, error) {
			return obj.Ret, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContractOutputResult_ret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContractOutputResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContractOutputResult_ok(ctx context.Context, field graphql.CollectedField, obj *contracts.ContractOutputResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ContractOutputResult_ok,
		func(ctx context.Context) (any, error) {
			return obj.Ok, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ContractOutputResult_ok(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContractOutputResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ElectionMember_key(ctx context.Context, field graphql.CollectedField, obj *elections.ElectionMember) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ElectionMember_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ElectionMember_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ElectionMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ElectionMember_account(ctx context.Context, field graphql.CollectedField, obj *elections.ElectionMember) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ElectionMember_account,
		func(ctx context.Context) (any, error) {
			return obj.Account, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ElectionMember_account(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ElectionMember",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ElectionResult_epoch(ctx context.Context, field graphql.CollectedField, obj *elections.ElectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ElectionResult_epoch,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ElectionResult().Epoch(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ElectionResult_epoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ElectionResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ElectionResult_net_id(ctx context.Context, field graphql.CollectedField, obj *elections.ElectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ElectionResult_net_id,
		func(ctx context.Context) (any, error) {
			return obj.NetId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ElectionResult_net_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ElectionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ElectionResult_type(ctx context.Context, field graphql.CollectedField, obj *elections.ElectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ElectionResult_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ElectionResult_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ElectionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ElectionResult_data(ctx context.Context, field graphql.CollectedField, obj *elections.ElectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ElectionResult_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ElectionResult_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ElectionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ElectionResult_members(ctx context.Context, field graphql.CollectedField, obj *elections.ElectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ElectionResult_members,
		func(ctx context.Context) (any, error) {
			return obj.Members, nil
		},
		nil,
		ec.marshalNElectionMember2vscnodemodulesdbvscelectionsElectionMember,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ElectionResult_members(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ElectionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_ElectionMember_key(ctx, field)
			case "account":
				return ec.fieldContext_ElectionMember_account(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ElectionMember", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ElectionResult_weights(ctx context.Context, field graphql.CollectedField, obj *elections.ElectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ElectionResult_weights,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ElectionResult().Weights(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ElectionResult_weights(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ElectionResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ElectionResult_protocol_version(ctx context.Context, field graphql.CollectedField, obj *elections.ElectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ElectionResult_protocol_version,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ElectionResult().ProtocolVersion(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ElectionResult_protocol_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ElectionResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ElectionResult_total_weight(ctx context.Context, field graphql.CollectedField, obj *elections.ElectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ElectionResult_total_weight,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ElectionResult().TotalWeight(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ElectionResult_total_weight(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ElectionResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ElectionResult_block_height(ctx context.Context, field graphql.CollectedField, obj *elections.ElectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ElectionResult_block_height,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.ElectionResult().BlockHeight(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ElectionResult_block_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ElectionResult",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ElectionResult_proposer(ctx context.Context, field graphql.CollectedField, obj *elections.ElectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ElectionResult_proposer,
		func(ctx context.Context) (any, error) {
			return obj.Proposer, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ElectionResult_proposer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ElectionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ElectionResult_tx_id(ctx context.Context, field graphql.CollectedField, obj *elections.ElectionResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ElectionResult_tx_id,
		func(ctx context.Context) (any, error) {
			return obj.TxId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ElectionResult_tx_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ElectionResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerAction_id(ctx context.Context, field graphql.CollectedField, obj *LedgerAction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerAction_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LedgerAction_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerAction_status(ctx context.Context, field graphql.CollectedField, obj *LedgerAction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerAction_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LedgerAction_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerAction_type(ctx context.Context, field graphql.CollectedField, obj *LedgerAction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerAction_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LedgerAction_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerAction_data(ctx context.Context, field graphql.CollectedField, obj *LedgerAction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerAction_data,
		func(ctx context.Context) (any, error) {
			return obj.Data, nil
		},
		nil,
		ec.marshalOMap2vscnodemodulesgqlmodelMap,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LedgerAction_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerAction_asset(ctx context.Context, field graphql.CollectedField, obj *LedgerAction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerAction_asset,
		func(ctx context.Context) (any, error) {
			return obj.Asset, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LedgerAction_asset(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerAction_amount(ctx context.Context, field graphql.CollectedField, obj *LedgerAction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerAction_amount,
		func(ctx context.Context) (any, error) {
			return obj.Amount, nil
		},
		nil,
		ec.marshalOUint642vscnodemodulesgqlmodelUint64,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LedgerAction_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerAction_memo(ctx context.Context, field graphql.CollectedField, obj *LedgerAction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerAction_memo,
		func(ctx context.Context) (any, error) {
			return obj.Memo, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LedgerAction_memo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerAction_to(ctx context.Context, field graphql.CollectedField, obj *LedgerAction) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerAction_to,
		func(ctx context.Context) (any, error) {
			return obj.To, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LedgerAction_to(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerAction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerRecord_id(ctx context.Context, field graphql.CollectedField, obj *ledger_db.LedgerRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerRecord_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LedgerRecord_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerRecord_amount(ctx context.Context, field graphql.CollectedField, obj *ledger_db.LedgerRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerRecord_amount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.LedgerRecord().Amount(ctx, obj)
		},
		nil,
		ec.marshalNInt642vscnodemodulesgqlmodelInt64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LedgerRecord_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerRecord_block_height(ctx context.Context, field graphql.CollectedField, obj *ledger_db.LedgerRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerRecord_block_height,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.LedgerRecord().BlockHeight(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LedgerRecord_block_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerRecord_timestamp(ctx context.Context, field graphql.CollectedField, obj *ledger_db.LedgerRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerRecord_timestamp,
		func(ctx context.Context) (any, error) {
			return obj.Timestamp, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LedgerRecord_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerRecord_from(ctx context.Context, field graphql.CollectedField, obj *ledger_db.LedgerRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerRecord_from,
		func(ctx context.Context) (any, error) {
			return obj.From, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LedgerRecord_from(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerRecord_owner(ctx context.Context, field graphql.CollectedField, obj *ledger_db.LedgerRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerRecord_owner,
		func(ctx context.Context) (any, error) {
			return obj.Owner, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LedgerRecord_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerRecord_type(ctx context.Context, field graphql.CollectedField, obj *ledger_db.LedgerRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerRecord_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LedgerRecord_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerRecord_asset(ctx context.Context, field graphql.CollectedField, obj *ledger_db.LedgerRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerRecord_asset,
		func(ctx context.Context) (any, error) {
			return obj.Asset, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LedgerRecord_asset(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LedgerRecord_tx_id(ctx context.Context, field graphql.CollectedField, obj *ledger_db.LedgerRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LedgerRecord_tx_id,
		func(ctx context.Context) (any, error) {
			return obj.TxId, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LedgerRecord_tx_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LedgerRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocalNodeInfo_version_id(ctx context.Context, field graphql.CollectedField, obj *LocalNodeInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LocalNodeInfo_version_id,
		func(ctx context.Context) (any, error) {
			return obj.VersionID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LocalNodeInfo_version_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocalNodeInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocalNodeInfo_git_commit(ctx context.Context, field graphql.CollectedField, obj *LocalNodeInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LocalNodeInfo_git_commit,
		func(ctx context.Context) (any, error) {
			return obj.GitCommit, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LocalNodeInfo_git_commit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocalNodeInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocalNodeInfo_last_processed_block(ctx context.Context, field graphql.CollectedField, obj *LocalNodeInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LocalNodeInfo_last_processed_block,
		func(ctx context.Context) (any, error) {
			return obj.LastProcessedBlock, nil
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LocalNodeInfo_last_processed_block(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocalNodeInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocalNodeInfo_epoch(ctx context.Context, field graphql.CollectedField, obj *LocalNodeInfo) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LocalNodeInfo_epoch,
		func(ctx context.Context) (any, error) {
			return obj.Epoch, nil
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LocalNodeInfo_epoch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocalNodeInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NonceRecord_account(ctx context.Context, field graphql.CollectedField, obj *nonces.NonceRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NonceRecord_account,
		func(ctx context.Context) (any, error) {
			return obj.Account, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NonceRecord_account(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NonceRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NonceRecord_nonce(ctx context.Context, field graphql.CollectedField, obj *nonces.NonceRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_NonceRecord_nonce,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.NonceRecord().Nonce(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_NonceRecord_nonce(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NonceRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpLogEvent_to(ctx context.Context, field graphql.CollectedField, obj *ledgerSystem.OpLogEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OpLogEvent_to,
		func(ctx context.Context) (any, error) {
			return obj.To, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OpLogEvent_to(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpLogEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpLogEvent_from(ctx context.Context, field graphql.CollectedField, obj *ledgerSystem.OpLogEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OpLogEvent_from,
		func(ctx context.Context) (any, error) {
			return obj.From, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OpLogEvent_from(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpLogEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpLogEvent_amount(ctx context.Context, field graphql.CollectedField, obj *ledgerSystem.OpLogEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OpLogEvent_amount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.OpLogEvent().Amount(ctx, obj)
		},
		nil,
		ec.marshalNInt642vscnodemodulesgqlmodelInt64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OpLogEvent_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpLogEvent",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpLogEvent_asset(ctx context.Context, field graphql.CollectedField, obj *ledgerSystem.OpLogEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OpLogEvent_asset,
		func(ctx context.Context) (any, error) {
			return obj.Asset, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OpLogEvent_asset(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpLogEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpLogEvent_memo(ctx context.Context, field graphql.CollectedField, obj *ledgerSystem.OpLogEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OpLogEvent_memo,
		func(ctx context.Context) (any, error) {
			return obj.Memo, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OpLogEvent_memo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpLogEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpLogEvent_type(ctx context.Context, field graphql.CollectedField, obj *ledgerSystem.OpLogEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OpLogEvent_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_OpLogEvent_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpLogEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OpLogEvent_params(ctx context.Context, field graphql.CollectedField, obj *ledgerSystem.OpLogEvent) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_OpLogEvent_params,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.OpLogEvent().Params(ctx, obj)
		},
		nil,
		ec.marshalOMap2vscnodemodulesgqlmodelMap,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_OpLogEvent_params(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OpLogEvent",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostingJsonKeys_ct(ctx context.Context, field graphql.CollectedField, obj *witnesses.PostingJsonKeys) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PostingJsonKeys_ct,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.PostingJsonKeys().Ct(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PostingJsonKeys_ct(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostingJsonKeys",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostingJsonKeys_t(ctx context.Context, field graphql.CollectedField, obj *witnesses.PostingJsonKeys) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PostingJsonKeys_t,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.PostingJsonKeys().T(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PostingJsonKeys_t(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostingJsonKeys",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PostingJsonKeys_key(ctx context.Context, field graphql.CollectedField, obj *witnesses.PostingJsonKeys) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PostingJsonKeys_key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_PostingJsonKeys_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PostingJsonKeys",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getStateByKeys(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_getStateByKeys,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().GetStateByKeys(ctx, fc.Args["contractId"].(string), fc.Args["keys"].([]string))
		},
		nil,
		ec.marshalOMap2vscnodemodulesgqlmodelMap,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_getStateByKeys(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getStateByKeys_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_findTransaction,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FindTransaction(ctx, fc.Args["filterOptions"].(*TransactionFilter))
		},
		nil,
		ec.marshalOTransactionRecord2vscnodemodulesdbvsctransactionsTransactionRecord,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_findTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionRecord_id(ctx, field)
			case "anchr_height":
				return ec.fieldContext_TransactionRecord_anchr_height(ctx, field)
			case "anchr_index":
				return ec.fieldContext_TransactionRecord_anchr_index(ctx, field)
			case "anchr_id":
				return ec.fieldContext_TransactionRecord_anchr_id(ctx, field)
			case "anchr_ts":
				return ec.fieldContext_TransactionRecord_anchr_ts(ctx, field)
			case "type":
				return ec.fieldContext_TransactionRecord_type(ctx, field)
			case "ops":
				return ec.fieldContext_TransactionRecord_ops(ctx, field)
			case "op_types":
				return ec.fieldContext_TransactionRecord_op_types(ctx, field)
			case "first_seen":
				return ec.fieldContext_TransactionRecord_first_seen(ctx, field)
			case "nonce":
				return ec.fieldContext_TransactionRecord_nonce(ctx, field)
			case "rc_limit":
				return ec.fieldContext_TransactionRecord_rc_limit(ctx, field)
			case "required_auths":
				return ec.fieldContext_TransactionRecord_required_auths(ctx, field)
			case "required_posting_auths":
				return ec.fieldContext_TransactionRecord_required_posting_auths(ctx, field)
			case "status":
				return ec.fieldContext_TransactionRecord_status(ctx, field)
			case "ledger":
				return ec.fieldContext_TransactionRecord_ledger(ctx, field)
			case "ledger_actions":
				return ec.fieldContext_TransactionRecord_ledger_actions(ctx, field)
			case "output":
				return ec.fieldContext_TransactionRecord_output(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findContractOutput(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_findContractOutput,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FindContractOutput(ctx, fc.Args["filterOptions"].(*ContractOutputFilter))
		},
		nil,
		ec.marshalOContractOutput2vscnodemodulesdbvsccontractsContractOutput,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_findContractOutput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContractOutput_id(ctx, field)
			case "block_height":
				return ec.fieldContext_ContractOutput_block_height(ctx, field)
			case "timestamp":
				return ec.fieldContext_ContractOutput_timestamp(ctx, field)
			case "contract_id":
				return ec.fieldContext_ContractOutput_contract_id(ctx, field)
			case "inputs":
				return ec.fieldContext_ContractOutput_inputs(ctx, field)
			case "state_merkle":
				return ec.fieldContext_ContractOutput_state_merkle(ctx, field)
			case "results":
				return ec.fieldContext_ContractOutput_results(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContractOutput", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findContractOutput_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findLedgerTXs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_findLedgerTXs,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FindLedgerTXs(ctx, fc.Args["filterOptions"].(*LedgerTxFilter))
		},
		nil,
		ec.marshalOLedgerRecord2vscnodemodulesdbvscledgerLedgerRecord,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_findLedgerTXs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LedgerRecord_id(ctx, field)
			case "amount":
				return ec.fieldContext_LedgerRecord_amount(ctx, field)
			case "block_height":
				return ec.fieldContext_LedgerRecord_block_height(ctx, field)
			case "timestamp":
				return ec.fieldContext_LedgerRecord_timestamp(ctx, field)
			case "from":
				return ec.fieldContext_LedgerRecord_from(ctx, field)
			case "owner":
				return ec.fieldContext_LedgerRecord_owner(ctx, field)
			case "type":
				return ec.fieldContext_LedgerRecord_type(ctx, field)
			case "asset":
				return ec.fieldContext_LedgerRecord_asset(ctx, field)
			case "tx_id":
				return ec.fieldContext_LedgerRecord_tx_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LedgerRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findLedgerTXs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findLedgerActions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_findLedgerActions,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FindLedgerActions(ctx, fc.Args["filterOptions"].(*LedgerActionsFilter))
		},
		nil,
		ec.marshalOActionRecord2vscnodemodulesdbvscledgerActionRecord,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_findLedgerActions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ActionRecord_id(ctx, field)
			case "status":
				return ec.fieldContext_ActionRecord_status(ctx, field)
			case "amount":
				return ec.fieldContext_ActionRecord_amount(ctx, field)
			case "asset":
				return ec.fieldContext_ActionRecord_asset(ctx, field)
			case "to":
				return ec.fieldContext_ActionRecord_to(ctx, field)
			case "memo":
				return ec.fieldContext_ActionRecord_memo(ctx, field)
			case "action_id":
				return ec.fieldContext_ActionRecord_action_id(ctx, field)
			case "type":
				return ec.fieldContext_ActionRecord_type(ctx, field)
			case "params":
				return ec.fieldContext_ActionRecord_params(ctx, field)
			case "block_height":
				return ec.fieldContext_ActionRecord_block_height(ctx, field)
			case "timestamp":
				return ec.fieldContext_ActionRecord_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ActionRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findLedgerActions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAccountBalance(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_getAccountBalance,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().GetAccountBalance(ctx, fc.Args["account"].(string), fc.Args["height"].(*model.Uint64))
		},
		nil,
		ec.marshalOBalanceRecord2vscnodemodulesdbvscledgerBalanceRecord,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_getAccountBalance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "account":
				return ec.fieldContext_BalanceRecord_account(ctx, field)
			case "block_height":
				return ec.fieldContext_BalanceRecord_block_height(ctx, field)
			case "hbd":
				return ec.fieldContext_BalanceRecord_hbd(ctx, field)
			case "hbd_avg":
				return ec.fieldContext_BalanceRecord_hbd_avg(ctx, field)
			case "hbd_modify":
				return ec.fieldContext_BalanceRecord_hbd_modify(ctx, field)
			case "hbd_claim":
				return ec.fieldContext_BalanceRecord_hbd_claim(ctx, field)
			case "hbd_savings":
				return ec.fieldContext_BalanceRecord_hbd_savings(ctx, field)
			case "hive":
				return ec.fieldContext_BalanceRecord_hive(ctx, field)
			case "hive_consensus":
				return ec.fieldContext_BalanceRecord_hive_consensus(ctx, field)
			case "consensus_unstaking":
				return ec.fieldContext_BalanceRecord_consensus_unstaking(ctx, field)
			case "pending_hbd_unstaking":
				return ec.fieldContext_BalanceRecord_pending_hbd_unstaking(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BalanceRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAccountBalance_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAccountRC(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_getAccountRC,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().GetAccountRc(ctx, fc.Args["account"].(string), fc.Args["height"].(*model.Uint64))
		},
		nil,
		ec.marshalORcRecord2vscnodemodulesdbvscrcsRcRecord,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_getAccountRC(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "account":
				return ec.fieldContext_RcRecord_account(ctx, field)
			case "amount":
				return ec.fieldContext_RcRecord_amount(ctx, field)
			case "block_height":
				return ec.fieldContext_RcRecord_block_height(ctx, field)
			case "max_rcs":
				return ec.fieldContext_RcRecord_max_rcs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RcRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAccountRC_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_findContract(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_findContract,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().FindContract(ctx, fc.Args["filterOptions"].(*FindContractFilter))
		},
		nil,
		ec.marshalOContract2vscnodemodulesdbvsccontractsContract,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_findContract(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Contract_id(ctx, field)
			case "code":
				return ec.fieldContext_Contract_code(ctx, field)
			case "name":
				return ec.fieldContext_Contract_name(ctx, field)
			case "description":
				return ec.fieldContext_Contract_description(ctx, field)
			case "creator":
				return ec.fieldContext_Contract_creator(ctx, field)
			case "owner":
				return ec.fieldContext_Contract_owner(ctx, field)
			case "tx_id":
				return ec.fieldContext_Contract_tx_id(ctx, field)
			case "creation_height":
				return ec.fieldContext_Contract_creation_height(ctx, field)
			case "creation_ts":
				return ec.fieldContext_Contract_creation_ts(ctx, field)
			case "runtime":
				return ec.fieldContext_Contract_runtime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Contract", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_findContract_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_submitTransactionV1(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_submitTransactionV1,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().SubmitTransactionV1(ctx, fc.Args["tx"].(string), fc.Args["sig"].(string))
		},
		nil,
		ec.marshalOTransactionSubmitResult2vscnodemodulesgqlgqlgenTransactionSubmitResult,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_submitTransactionV1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TransactionSubmitResult_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionSubmitResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_submitTransactionV1_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAccountNonce(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_getAccountNonce,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().GetAccountNonce(ctx, fc.Args["account"].(string))
		},
		nil,
		ec.marshalONonceRecord2vscnodemodulesdbvscnoncesNonceRecord,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_getAccountNonce(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "account":
				return ec.fieldContext_NonceRecord_account(ctx, field)
			case "nonce":
				return ec.fieldContext_NonceRecord_nonce(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NonceRecord", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAccountNonce_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_localNodeInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_localNodeInfo,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Query().LocalNodeInfo(ctx)
		},
		nil,
		ec.marshalOLocalNodeInfo2vscnodemodulesgqlgqlgenLocalNodeInfo,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_localNodeInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version_id":
				return ec.fieldContext_LocalNodeInfo_version_id(ctx, field)
			case "git_commit":
				return ec.fieldContext_LocalNodeInfo_git_commit(ctx, field)
			case "last_processed_block":
				return ec.fieldContext_LocalNodeInfo_last_processed_block(ctx, field)
			case "epoch":
				return ec.fieldContext_LocalNodeInfo_epoch(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocalNodeInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getWitness(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_getWitness,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().GetWitness(ctx, fc.Args["account"].(string), fc.Args["height"].(*model.Uint64))
		},
		nil,
		ec.marshalOWitness2vscnodemodulesdbvscwitnessesWitness,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_getWitness(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "account":
				return ec.fieldContext_Witness_account(ctx, field)
			case "height":
				return ec.fieldContext_Witness_height(ctx, field)
			case "did_keys":
				return ec.fieldContext_Witness_did_keys(ctx, field)
			case "enabled":
				return ec.fieldContext_Witness_enabled(ctx, field)
			case "git_commit":
				return ec.fieldContext_Witness_git_commit(ctx, field)
			case "net_id":
				return ec.fieldContext_Witness_net_id(ctx, field)
			case "peer_id":
				return ec.fieldContext_Witness_peer_id(ctx, field)
			case "protocol_version":
				return ec.fieldContext_Witness_protocol_version(ctx, field)
			case "ts":
				return ec.fieldContext_Witness_ts(ctx, field)
			case "tx_id":
				return ec.fieldContext_Witness_tx_id(ctx, field)
			case "version_id":
				return ec.fieldContext_Witness_version_id(ctx, field)
			case "gateway_key":
				return ec.fieldContext_Witness_gateway_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Witness", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getWitness_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_witnessNodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_witnessNodes,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().WitnessNodes(ctx, fc.Args["height"].(model.Uint64))
		},
		nil,
		ec.marshalNWitness2vscnodemodulesdbvscwitnessesWitness,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_witnessNodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "account":
				return ec.fieldContext_Witness_account(ctx, field)
			case "height":
				return ec.fieldContext_Witness_height(ctx, field)
			case "did_keys":
				return ec.fieldContext_Witness_did_keys(ctx, field)
			case "enabled":
				return ec.fieldContext_Witness_enabled(ctx, field)
			case "git_commit":
				return ec.fieldContext_Witness_git_commit(ctx, field)
			case "net_id":
				return ec.fieldContext_Witness_net_id(ctx, field)
			case "peer_id":
				return ec.fieldContext_Witness_peer_id(ctx, field)
			case "protocol_version":
				return ec.fieldContext_Witness_protocol_version(ctx, field)
			case "ts":
				return ec.fieldContext_Witness_ts(ctx, field)
			case "tx_id":
				return ec.fieldContext_Witness_tx_id(ctx, field)
			case "version_id":
				return ec.fieldContext_Witness_version_id(ctx, field)
			case "gateway_key":
				return ec.fieldContext_Witness_gateway_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Witness", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_witnessNodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_witnessSchedule(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_witnessSchedule,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().WitnessSchedule(ctx, fc.Args["height"].(model.Uint64))
		},
		nil,
		ec.marshalNWitnessSlot2vscnodemodulesstateprocessingWitnessSlot,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_witnessSchedule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "account":
				return ec.fieldContext_WitnessSlot_account(ctx, field)
			case "bn":
				return ec.fieldContext_WitnessSlot_bn(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WitnessSlot", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_witnessSchedule_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_witnessStake(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_witnessStake,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().WitnessStake(ctx, fc.Args["account"].(string))
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_witnessStake(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_witnessStake_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getDagByCID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_getDagByCID,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().GetDagByCid(ctx, fc.Args["cidString"].(string))
		},
		nil,
		ec.marshalNJSON2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_getDagByCID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type JSON does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getDagByCID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getElection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_getElection,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().GetElection(ctx, fc.Args["epoch"].(model.Uint64))
		},
		nil,
		ec.marshalOElectionResult2vscnodemodulesdbvscelectionsElectionResult,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_getElection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "epoch":
				return ec.fieldContext_ElectionResult_epoch(ctx, field)
			case "net_id":
				return ec.fieldContext_ElectionResult_net_id(ctx, field)
			case "type":
				return ec.fieldContext_ElectionResult_type(ctx, field)
			case "data":
				return ec.fieldContext_ElectionResult_data(ctx, field)
			case "members":
				return ec.fieldContext_ElectionResult_members(ctx, field)
			case "weights":
				return ec.fieldContext_ElectionResult_weights(ctx, field)
			case "protocol_version":
				return ec.fieldContext_ElectionResult_protocol_version(ctx, field)
			case "total_weight":
				return ec.fieldContext_ElectionResult_total_weight(ctx, field)
			case "block_height":
				return ec.fieldContext_ElectionResult_block_height(ctx, field)
			case "proposer":
				return ec.fieldContext_ElectionResult_proposer(ctx, field)
			case "tx_id":
				return ec.fieldContext_ElectionResult_tx_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ElectionResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getElection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_electionByBlockHeight(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_electionByBlockHeight,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().ElectionByBlockHeight(ctx, fc.Args["blockHeight"].(*model.Uint64))
		},
		nil,
		ec.marshalNElectionResult2vscnodemodulesdbvscelectionsElectionResult,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Query_electionByBlockHeight(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "epoch":
				return ec.fieldContext_ElectionResult_epoch(ctx, field)
			case "net_id":
				return ec.fieldContext_ElectionResult_net_id(ctx, field)
			case "type":
				return ec.fieldContext_ElectionResult_type(ctx, field)
			case "data":
				return ec.fieldContext_ElectionResult_data(ctx, field)
			case "members":
				return ec.fieldContext_ElectionResult_members(ctx, field)
			case "weights":
				return ec.fieldContext_ElectionResult_weights(ctx, field)
			case "protocol_version":
				return ec.fieldContext_ElectionResult_protocol_version(ctx, field)
			case "total_weight":
				return ec.fieldContext_ElectionResult_total_weight(ctx, field)
			case "block_height":
				return ec.fieldContext_ElectionResult_block_height(ctx, field)
			case "proposer":
				return ec.fieldContext_ElectionResult_proposer(ctx, field)
			case "tx_id":
				return ec.fieldContext_ElectionResult_tx_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ElectionResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_electionByBlockHeight_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getTssKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_getTssKey,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().GetTssKey(ctx, fc.Args["keyId"].(string))
		},
		nil,
		ec.marshalOTssKey2vscnodemodulesgqlgqlgenTssKey,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_getTssKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TssKey_id(ctx, field)
			case "status":
				return ec.fieldContext_TssKey_status(ctx, field)
			case "PublicKey":
				return ec.fieldContext_TssKey_PublicKey(ctx, field)
			case "Owner":
				return ec.fieldContext_TssKey_Owner(ctx, field)
			case "Algo":
				return ec.fieldContext_TssKey_Algo(ctx, field)
			case "CreatedHeight":
				return ec.fieldContext_TssKey_CreatedHeight(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TssKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getTssKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getTssRequests(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query_getTssRequests,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.resolvers.Query().GetTssRequests(ctx, fc.Args["keyId"].(string), fc.Args["msgHex"].([]string))
		},
		nil,
		ec.marshalOTssRequest2vscnodemodulesgqlgqlgenTssRequest,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query_getTssRequests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TssRequest_id(ctx, field)
			case "status":
				return ec.fieldContext_TssRequest_status(ctx, field)
			case "keyId":
				return ec.fieldContext_TssRequest_keyId(ctx, field)
			case "msg":
				return ec.fieldContext_TssRequest_msg(ctx, field)
			case "sig":
				return ec.fieldContext_TssRequest_sig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TssRequest", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getTssRequests_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___type,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return ec.introspectType(fc.Args["name"].(string))
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Query___schema,
		func(ctx context.Context) (any, error) {
			return ec.introspectSchema()
		},
		nil,
		ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RcRecord_account(ctx context.Context, field graphql.CollectedField, obj *rcDb.RcRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RcRecord_account,
		func(ctx context.Context) (any, error) {
			return obj.Account, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RcRecord_account(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RcRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RcRecord_amount(ctx context.Context, field graphql.CollectedField, obj *rcDb.RcRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RcRecord_amount,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.RcRecord().Amount(ctx, obj)
		},
		nil,
		ec.marshalNInt642vscnodemodulesgqlmodelInt64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RcRecord_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RcRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RcRecord_block_height(ctx context.Context, field graphql.CollectedField, obj *rcDb.RcRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RcRecord_block_height,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.RcRecord().BlockHeight(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RcRecord_block_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RcRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RcRecord_max_rcs(ctx context.Context, field graphql.CollectedField, obj *rcDb.RcRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_RcRecord_max_rcs,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.RcRecord().MaxRcs(ctx, obj)
		},
		nil,
		ec.marshalNInt642vscnodemodulesgqlmodelInt64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_RcRecord_max_rcs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RcRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionOperation_required_auths(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionOperation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionOperation_required_auths,
		func(ctx context.Context) (any, error) {
			return obj.RequiredAuths, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionOperation_required_auths(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionOperation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionOperation_type(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionOperation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionOperation_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionOperation_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionOperation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionOperation_index(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionOperation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionOperation_index,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TransactionOperation().Index(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionOperation_index(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionOperation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionOperation_data(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionOperation) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionOperation_data,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TransactionOperation().Data(ctx, obj)
		},
		nil,
		ec.marshalOMap2vscnodemodulesgqlmodelMap,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionOperation_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionOperation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionOutput_index(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionOutput) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionOutput_index,
		func(ctx context.Context) (any, error) {
			return obj.Index, nil
		},
		nil,
		ec.marshalOInt2int,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionOutput_index(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionOutput_id(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionOutput) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionOutput_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionOutput_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_id(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_id,
		func(ctx context.Context) (any, error) {
			return obj.Id, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_anchr_height(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_anchr_height,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TransactionRecord().AnchrHeight(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_anchr_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_anchr_index(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_anchr_index,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TransactionRecord().AnchrIndex(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_anchr_index(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_anchr_id(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_anchr_id,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TransactionRecord().AnchrID(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_anchr_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_anchr_ts(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_anchr_ts,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TransactionRecord().AnchrTs(ctx, obj)
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_anchr_ts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_type(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_ops(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_ops,
		func(ctx context.Context) (any, error) {
			return obj.Ops, nil
		},
		nil,
		ec.marshalOTransactionOperation2vscnodemodulesdbvsctransactionsTransactionOperation,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_ops(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "required_auths":
				return ec.fieldContext_TransactionOperation_required_auths(ctx, field)
			case "type":
				return ec.fieldContext_TransactionOperation_type(ctx, field)
			case "index":
				return ec.fieldContext_TransactionOperation_index(ctx, field)
			case "data":
				return ec.fieldContext_TransactionOperation_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionOperation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_op_types(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_op_types,
		func(ctx context.Context) (any, error) {
			return obj.OpTypes, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_op_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_first_seen(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_first_seen,
		func(ctx context.Context) (any, error) {
			return obj.FirstSeen, nil
		},
		nil,
		ec.marshalNDateTime2timeTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_first_seen(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_nonce(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_nonce,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TransactionRecord().Nonce(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_nonce(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_rc_limit(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_rc_limit,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TransactionRecord().RcLimit(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_rc_limit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_required_auths(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_required_auths,
		func(ctx context.Context) (any, error) {
			return obj.RequiredAuths, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_required_auths(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_required_posting_auths(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_required_posting_auths,
		func(ctx context.Context) (any, error) {
			return obj.RequiredPostingAuths, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_required_posting_auths(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_status(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_ledger(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_ledger,
		func(ctx context.Context) (any, error) {
			return obj.Ledger, nil
		},
		nil,
		ec.marshalOOpLogEvent2vscnodemodulesledgersystemOpLogEvent,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_ledger(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "to":
				return ec.fieldContext_OpLogEvent_to(ctx, field)
			case "from":
				return ec.fieldContext_OpLogEvent_from(ctx, field)
			case "amount":
				return ec.fieldContext_OpLogEvent_amount(ctx, field)
			case "asset":
				return ec.fieldContext_OpLogEvent_asset(ctx, field)
			case "memo":
				return ec.fieldContext_OpLogEvent_memo(ctx, field)
			case "type":
				return ec.fieldContext_OpLogEvent_type(ctx, field)
			case "params":
				return ec.fieldContext_OpLogEvent_params(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OpLogEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_ledger_actions(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_ledger_actions,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.TransactionRecord().LedgerActions(ctx, obj)
		},
		nil,
		ec.marshalOLedgerAction2vscnodemodulesgqlgqlgenLedgerAction,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_ledger_actions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LedgerAction_id(ctx, field)
			case "status":
				return ec.fieldContext_LedgerAction_status(ctx, field)
			case "type":
				return ec.fieldContext_LedgerAction_type(ctx, field)
			case "data":
				return ec.fieldContext_LedgerAction_data(ctx, field)
			case "asset":
				return ec.fieldContext_LedgerAction_asset(ctx, field)
			case "amount":
				return ec.fieldContext_LedgerAction_amount(ctx, field)
			case "memo":
				return ec.fieldContext_LedgerAction_memo(ctx, field)
			case "to":
				return ec.fieldContext_LedgerAction_to(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LedgerAction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionRecord_output(ctx context.Context, field graphql.CollectedField, obj *transactions.TransactionRecord) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionRecord_output,
		func(ctx context.Context) (any, error) {
			return obj.Output, nil
		},
		nil,
		ec.marshalOTransactionOutput2vscnodemodulesdbvsctransactionsTransactionOutput,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionRecord_output(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "index":
				return ec.fieldContext_TransactionOutput_index(ctx, field)
			case "id":
				return ec.fieldContext_TransactionOutput_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionOutput", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionSubmitResult_id(ctx context.Context, field graphql.CollectedField, obj *TransactionSubmitResult) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TransactionSubmitResult_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_TransactionSubmitResult_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionSubmitResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TssKey_id(ctx context.Context, field graphql.CollectedField, obj *TssKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TssKey_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TssKey_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TssKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TssKey_status(ctx context.Context, field graphql.CollectedField, obj *TssKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TssKey_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TssKey_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TssKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TssKey_PublicKey(ctx context.Context, field graphql.CollectedField, obj *TssKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TssKey_PublicKey,
		func(ctx context.Context) (any, error) {
			return obj.PublicKey, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TssKey_PublicKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TssKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TssKey_Owner(ctx context.Context, field graphql.CollectedField, obj *TssKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TssKey_Owner,
		func(ctx context.Context) (any, error) {
			return obj.Owner, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TssKey_Owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TssKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TssKey_Algo(ctx context.Context, field graphql.CollectedField, obj *TssKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TssKey_Algo,
		func(ctx context.Context) (any, error) {
			return obj.Algo, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TssKey_Algo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TssKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TssKey_CreatedHeight(ctx context.Context, field graphql.CollectedField, obj *TssKey) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TssKey_CreatedHeight,
		func(ctx context.Context) (any, error) {
			return obj.CreatedHeight, nil
		},
		nil,
		ec.marshalNInt2int,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TssKey_CreatedHeight(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TssKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TssRequest_id(ctx context.Context, field graphql.CollectedField, obj *TssRequest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TssRequest_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TssRequest_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TssRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TssRequest_status(ctx context.Context, field graphql.CollectedField, obj *TssRequest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TssRequest_status,
		func(ctx context.Context) (any, error) {
			return obj.Status, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TssRequest_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TssRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TssRequest_keyId(ctx context.Context, field graphql.CollectedField, obj *TssRequest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TssRequest_keyId,
		func(ctx context.Context) (any, error) {
			return obj.KeyID, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TssRequest_keyId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TssRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TssRequest_msg(ctx context.Context, field graphql.CollectedField, obj *TssRequest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TssRequest_msg,
		func(ctx context.Context) (any, error) {
			return obj.Msg, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TssRequest_msg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TssRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TssRequest_sig(ctx context.Context, field graphql.CollectedField, obj *TssRequest) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_TssRequest_sig,
		func(ctx context.Context) (any, error) {
			return obj.Sig, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_TssRequest_sig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TssRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Witness_account(ctx context.Context, field graphql.CollectedField, obj *witnesses.Witness) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Witness_account,
		func(ctx context.Context) (any, error) {
			return obj.Account, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Witness_account(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Witness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Witness_height(ctx context.Context, field graphql.CollectedField, obj *witnesses.Witness) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Witness_height,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Witness().Height(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Witness_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Witness",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Witness_did_keys(ctx context.Context, field graphql.CollectedField, obj *witnesses.Witness) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Witness_did_keys,
		func(ctx context.Context) (any, error) {
			return obj.DidKeys, nil
		},
		nil,
		ec.marshalNPostingJsonKeys2vscnodemodulesdbvscwitnessesPostingJsonKeys,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Witness_did_keys(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Witness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ct":
				return ec.fieldContext_PostingJsonKeys_ct(ctx, field)
			case "t":
				return ec.fieldContext_PostingJsonKeys_t(ctx, field)
			case "key":
				return ec.fieldContext_PostingJsonKeys_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PostingJsonKeys", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Witness_enabled(ctx context.Context, field graphql.CollectedField, obj *witnesses.Witness) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Witness_enabled,
		func(ctx context.Context) (any, error) {
			return obj.Enabled, nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Witness_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Witness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Witness_git_commit(ctx context.Context, field graphql.CollectedField, obj *witnesses.Witness) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Witness_git_commit,
		func(ctx context.Context) (any, error) {
			return obj.GitCommit, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Witness_git_commit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Witness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Witness_net_id(ctx context.Context, field graphql.CollectedField, obj *witnesses.Witness) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Witness_net_id,
		func(ctx context.Context) (any, error) {
			return obj.NetId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Witness_net_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Witness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Witness_peer_id(ctx context.Context, field graphql.CollectedField, obj *witnesses.Witness) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Witness_peer_id,
		func(ctx context.Context) (any, error) {
			return obj.PeerId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Witness_peer_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Witness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Witness_protocol_version(ctx context.Context, field graphql.CollectedField, obj *witnesses.Witness) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Witness_protocol_version,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Witness().ProtocolVersion(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Witness_protocol_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Witness",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Witness_ts(ctx context.Context, field graphql.CollectedField, obj *witnesses.Witness) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Witness_ts,
		func(ctx context.Context) (any, error) {
			return obj.Ts, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Witness_ts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Witness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Witness_tx_id(ctx context.Context, field graphql.CollectedField, obj *witnesses.Witness) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Witness_tx_id,
		func(ctx context.Context) (any, error) {
			return obj.TxId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Witness_tx_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Witness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Witness_version_id(ctx context.Context, field graphql.CollectedField, obj *witnesses.Witness) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Witness_version_id,
		func(ctx context.Context) (any, error) {
			return obj.VersionId, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Witness_version_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Witness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Witness_gateway_key(ctx context.Context, field graphql.CollectedField, obj *witnesses.Witness) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Witness_gateway_key,
		func(ctx context.Context) (any, error) {
			return obj.GatewayKey, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Witness_gateway_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Witness",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WitnessSlot_account(ctx context.Context, field graphql.CollectedField, obj *state_engine.WitnessSlot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WitnessSlot_account,
		func(ctx context.Context) (any, error) {
			return obj.Account, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_WitnessSlot_account(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WitnessSlot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WitnessSlot_bn(ctx context.Context, field graphql.CollectedField, obj *state_engine.WitnessSlot) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_WitnessSlot_bn,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.WitnessSlot().Bn(ctx, obj)
		},
		nil,
		ec.marshalNUint642vscnodemodulesgqlmodelUint64,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_WitnessSlot_bn(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WitnessSlot",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_isRepeatable,
		func(ctx context.Context) (any, error) {
			return obj.IsRepeatable, nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_locations,
		func(ctx context.Context) (any, error) {
			return obj.Locations, nil
		},
		nil,
		ec.marshalN__DirectiveLocation2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Directive_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___EnumValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_args,
		func(ctx context.Context) (any, error) {
			return obj.Args, nil
		},
		nil,
		ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Field_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_defaultValue,
		func(ctx context.Context) (any, error) {
			return obj.DefaultValue, nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_isDeprecated,
		func(ctx context.Context) (any, error) {
			return obj.IsDeprecated(), nil
		},
		nil,
		ec.marshalNBoolean2bool,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___InputValue_deprecationReason,
		func(ctx context.Context) (any, error) {
			return obj.DeprecationReason(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_types,
		func(ctx context.Context) (any, error) {
			return obj.Types(), nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_queryType,
		func(ctx context.Context) (any, error) {
			return obj.QueryType(), nil
		},
		nil,
		ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_mutationType,
		func(ctx context.Context) (any, error) {
			return obj.MutationType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_subscriptionType,
		func(ctx context.Context) (any, error) {
			return obj.SubscriptionType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Schema_directives,
		func(ctx context.Context) (any, error) {
			return obj.Directives(), nil
		},
		nil,
		ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_kind,
		func(ctx context.Context) (any, error) {
			return obj.Kind(), nil
		},
		nil,
		ec.marshalN__TypeKind2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_name,
		func(ctx context.Context) (any, error) {
			return obj.Name(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_description,
		func(ctx context.Context) (any, error) {
			return obj.Description(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_specifiedByURL,
		func(ctx context.Context) (any, error) {
			return obj.SpecifiedByURL(), nil
		},
		nil,
		ec.marshalOString2string,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_fields,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_interfaces,
		func(ctx context.Context) (any, error) {
			return obj.Interfaces(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_possibleTypes,
		func(ctx context.Context) (any, error) {
			return obj.PossibleTypes(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_enumValues,
		func(ctx context.Context) (any, error) {
			fc := graphql.GetFieldContext(ctx)
			return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
		},
		nil,
		ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_inputFields,
		func(ctx context.Context) (any, error) {
			return obj.InputFields(), nil
		},
		nil,
		ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_ofType,
		func(ctx context.Context) (any, error) {
			return obj.OfType(), nil
		},
		nil,
		ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext___Type_isOneOf,
		func(ctx context.Context) (any, error) {
			return obj.IsOneOf(), nil
		},
		nil,
		ec.marshalOBoolean2bool,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputContractOutputFilter(ctx context.Context, obj any) (ContractOutputFilter, error) {
	var it ContractOutputFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"byId", "byInput", "byContract", "fromBlock", "toBlock", "offset", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "byId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByID = data
		case "byInput":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byInput"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByInput = data
		case "byContract":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byContract"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByContract = data
		case "fromBlock":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fromBlock"))
			data, err := ec.unmarshalOUint642vscnodemodulesgqlmodelUint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromBlock = data
		case "toBlock":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toBlock"))
			data, err := ec.unmarshalOUint642vscnodemodulesgqlmodelUint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToBlock = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFindContractFilter(ctx context.Context, obj any) (FindContractFilter, error) {
	var it FindContractFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"byId", "byCode", "historical", "offset", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "byId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByID = data
		case "byCode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byCode"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByCode = data
		case "historical":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("historical"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Historical = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLedgerActionsFilter(ctx context.Context, obj any) (LedgerActionsFilter, error) {
	var it LedgerActionsFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"byTxId", "byActionId", "byAccount", "byTypes", "byAsset", "byStatus", "fromBlock", "toBlock", "offset", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "byTxId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byTxId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByTxID = data
		case "byActionId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byActionId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByActionID = data
		case "byAccount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byAccount"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByAccount = data
		case "byTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byTypes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByTypes = data
		case "byAsset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byAsset"))
			data, err := ec.unmarshalOAsset2vscnodemodulesdbvscledgerAsset(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByAsset = data
		case "byStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byStatus"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByStatus = data
		case "fromBlock":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fromBlock"))
			data, err := ec.unmarshalOUint642vscnodemodulesgqlmodelUint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromBlock = data
		case "toBlock":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toBlock"))
			data, err := ec.unmarshalOUint642vscnodemodulesgqlmodelUint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToBlock = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLedgerTxFilter(ctx context.Context, obj any) (LedgerTxFilter, error) {
	var it LedgerTxFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"byToFrom", "byTxId", "byTypes", "byAsset", "fromBlock", "toBlock", "offset", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "byToFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byToFrom"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByToFrom = data
		case "byTxId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byTxId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByTxID = data
		case "byTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byTypes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByTypes = data
		case "byAsset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byAsset"))
			data, err := ec.unmarshalOAsset2vscnodemodulesdbvscledgerAsset(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByAsset = data
		case "fromBlock":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fromBlock"))
			data, err := ec.unmarshalOUint642vscnodemodulesgqlmodelUint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromBlock = data
		case "toBlock":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toBlock"))
			data, err := ec.unmarshalOUint642vscnodemodulesgqlmodelUint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToBlock = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionFilter(ctx context.Context, obj any) (TransactionFilter, error) {
	var it TransactionFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"byId", "byIds", "byAccount", "byContract", "byStatus", "byType", "byLedgerToFrom", "byLedgerTypes", "fromBlock", "toBlock", "offset", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "byId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByID = data
		case "byIds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byIds"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByIds = data
		case "byAccount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byAccount"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByAccount = data
		case "byContract":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byContract"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByContract = data
		case "byStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byStatus"))
			data, err := ec.unmarshalOTransactionStatus2vscnodemodulesdbvsctransactionsTransactionStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByStatus = data
		case "byType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byType"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByType = data
		case "byLedgerToFrom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byLedgerToFrom"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByLedgerToFrom = data
		case "byLedgerTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byLedgerTypes"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ByLedgerTypes = data
		case "fromBlock":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fromBlock"))
			data, err := ec.unmarshalOUint642vscnodemodulesgqlmodelUint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromBlock = data
		case "toBlock":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toBlock"))
			data, err := ec.unmarshalOUint642vscnodemodulesgqlmodelUint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToBlock = data
		case "offset":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Offset = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var actionRecordImplementors = []string{"ActionRecord"}

func (ec *executionContext) _ActionRecord(ctx context.Context, sel ast.SelectionSet, obj *ledger_db.ActionRecord) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, actionRecordImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ActionRecord")
		case "id":
			out.Values[i] = ec._ActionRecord_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._ActionRecord_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "amount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ActionRecord_amount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "asset":
			out.Values[i] = ec._ActionRecord_asset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "to":
			out.Values[i] = ec._ActionRecord_to(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "memo":
			out.Values[i] = ec._ActionRecord_memo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "action_id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ActionRecord_action_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			out.Values[i] = ec._ActionRecord_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "params":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ActionRecord_params(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "block_height":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ActionRecord_block_height(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "timestamp":
			out.Values[i] = ec._ActionRecord_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var balanceRecordImplementors = []string{"BalanceRecord"}

func (ec *executionContext) _BalanceRecord(ctx context.Context, sel ast.SelectionSet, obj *ledger_db.BalanceRecord) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, balanceRecordImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BalanceRecord")
		case "account":
			out.Values[i] = ec._BalanceRecord_account(ctx, field, obj)
		case "block_height":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BalanceRecord_block_height(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hbd":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BalanceRecord_hbd(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hbd_avg":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BalanceRecord_hbd_avg(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hbd_modify":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BalanceRecord_hbd_modify(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hbd_claim":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BalanceRecord_hbd_claim(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hbd_savings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BalanceRecord_hbd_savings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hive":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BalanceRecord_hive(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hive_consensus":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BalanceRecord_hive_consensus(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "consensus_unstaking":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BalanceRecord_consensus_unstaking(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "pending_hbd_unstaking":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BalanceRecord_pending_hbd_unstaking(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var contractImplementors = []string{"Contract"}

func (ec *executionContext) _Contract(ctx context.Context, sel ast.SelectionSet, obj *contracts.Contract) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, contractImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Contract")
		case "id":
			out.Values[i] = ec._Contract_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "code":
			out.Values[i] = ec._Contract_code(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Contract_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Contract_description(ctx, field, obj)
		case "creator":
			out.Values[i] = ec._Contract_creator(ctx, field, obj)
		case "owner":
			out.Values[i] = ec._Contract_owner(ctx, field, obj)
		case "tx_id":
			out.Values[i] = ec._Contract_tx_id(ctx, field, obj)
		case "creation_height":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Contract_creation_height(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "creation_ts":
			out.Values[i] = ec._Contract_creation_ts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "runtime":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Contract_runtime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var contractOutputImplementors = []string{"ContractOutput"}

func (ec *executionContext) _ContractOutput(ctx context.Context, sel ast.SelectionSet, obj *contracts.ContractOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, contractOutputImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContractOutput")
		case "id":
			out.Values[i] = ec._ContractOutput_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "block_height":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContractOutput_block_height(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "timestamp":
			out.Values[i] = ec._ContractOutput_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "contract_id":
			out.Values[i] = ec._ContractOutput_contract_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "inputs":
			out.Values[i] = ec._ContractOutput_inputs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "state_merkle":
			out.Values[i] = ec._ContractOutput_state_merkle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "results":
			out.Values[i] = ec._ContractOutput_results(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var contractOutputResultImplementors = []string{"ContractOutputResult"}

func (ec *executionContext) _ContractOutputResult(ctx context.Context, sel ast.SelectionSet, obj *contracts.ContractOutputResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, contractOutputResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContractOutputResult")
		case "ret":
			out.Values[i] = ec._ContractOutputResult_ret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ok":
			out.Values[i] = ec._ContractOutputResult_ok(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var electionMemberImplementors = []string{"ElectionMember"}

func (ec *executionContext) _ElectionMember(ctx context.Context, sel ast.SelectionSet, obj *elections.ElectionMember) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, electionMemberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ElectionMember")
		case "key":
			out.Values[i] = ec._ElectionMember_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "account":
			out.Values[i] = ec._ElectionMember_account(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var electionResultImplementors = []string{"ElectionResult"}

func (ec *executionContext) _ElectionResult(ctx context.Context, sel ast.SelectionSet, obj *elections.ElectionResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, electionResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ElectionResult")
		case "epoch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ElectionResult_epoch(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "net_id":
			out.Values[i] = ec._ElectionResult_net_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._ElectionResult_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "data":
			out.Values[i] = ec._ElectionResult_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "members":
			out.Values[i] = ec._ElectionResult_members(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "weights":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ElectionResult_weights(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "protocol_version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ElectionResult_protocol_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "total_weight":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ElectionResult_total_weight(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "block_height":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ElectionResult_block_height(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "proposer":
			out.Values[i] = ec._ElectionResult_proposer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tx_id":
			out.Values[i] = ec._ElectionResult_tx_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ledgerActionImplementors = []string{"LedgerAction"}

func (ec *executionContext) _LedgerAction(ctx context.Context, sel ast.SelectionSet, obj *LedgerAction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ledgerActionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LedgerAction")
		case "id":
			out.Values[i] = ec._LedgerAction_id(ctx, field, obj)
		case "status":
			out.Values[i] = ec._LedgerAction_status(ctx, field, obj)
		case "type":
			out.Values[i] = ec._LedgerAction_type(ctx, field, obj)
		case "data":
			out.Values[i] = ec._LedgerAction_data(ctx, field, obj)
		case "asset":
			out.Values[i] = ec._LedgerAction_asset(ctx, field, obj)
		case "amount":
			out.Values[i] = ec._LedgerAction_amount(ctx, field, obj)
		case "memo":
			out.Values[i] = ec._LedgerAction_memo(ctx, field, obj)
		case "to":
			out.Values[i] = ec._LedgerAction_to(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ledgerRecordImplementors = []string{"LedgerRecord"}

func (ec *executionContext) _LedgerRecord(ctx context.Context, sel ast.SelectionSet, obj *ledger_db.LedgerRecord) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ledgerRecordImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LedgerRecord")
		case "id":
			out.Values[i] = ec._LedgerRecord_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "amount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LedgerRecord_amount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "block_height":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LedgerRecord_block_height(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "timestamp":
			out.Values[i] = ec._LedgerRecord_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "from":
			out.Values[i] = ec._LedgerRecord_from(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "owner":
			out.Values[i] = ec._LedgerRecord_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._LedgerRecord_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "asset":
			out.Values[i] = ec._LedgerRecord_asset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tx_id":
			out.Values[i] = ec._LedgerRecord_tx_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var localNodeInfoImplementors = []string{"LocalNodeInfo"}

func (ec *executionContext) _LocalNodeInfo(ctx context.Context, sel ast.SelectionSet, obj *LocalNodeInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, localNodeInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LocalNodeInfo")
		case "version_id":
			out.Values[i] = ec._LocalNodeInfo_version_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "git_commit":
			out.Values[i] = ec._LocalNodeInfo_git_commit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "last_processed_block":
			out.Values[i] = ec._LocalNodeInfo_last_processed_block(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "epoch":
			out.Values[i] = ec._LocalNodeInfo_epoch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nonceRecordImplementors = []string{"NonceRecord"}

func (ec *executionContext) _NonceRecord(ctx context.Context, sel ast.SelectionSet, obj *nonces.NonceRecord) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nonceRecordImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NonceRecord")
		case "account":
			out.Values[i] = ec._NonceRecord_account(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "nonce":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._NonceRecord_nonce(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var opLogEventImplementors = []string{"OpLogEvent"}

func (ec *executionContext) _OpLogEvent(ctx context.Context, sel ast.SelectionSet, obj *ledgerSystem.OpLogEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, opLogEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OpLogEvent")
		case "to":
			out.Values[i] = ec._OpLogEvent_to(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "from":
			out.Values[i] = ec._OpLogEvent_from(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "amount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpLogEvent_amount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "asset":
			out.Values[i] = ec._OpLogEvent_asset(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "memo":
			out.Values[i] = ec._OpLogEvent_memo(ctx, field, obj)
		case "type":
			out.Values[i] = ec._OpLogEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "params":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OpLogEvent_params(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var postingJsonKeysImplementors = []string{"PostingJsonKeys"}

func (ec *executionContext) _PostingJsonKeys(ctx context.Context, sel ast.SelectionSet, obj *witnesses.PostingJsonKeys) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, postingJsonKeysImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PostingJsonKeys")
		case "ct":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PostingJsonKeys_ct(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "t":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PostingJsonKeys_t(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "key":
			out.Values[i] = ec._PostingJsonKeys_key(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getStateByKeys":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getStateByKeys(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findTransaction":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findTransaction(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findContractOutput":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findContractOutput(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findLedgerTXs":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findLedgerTXs(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findLedgerActions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findLedgerActions(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getAccountBalance":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAccountBalance(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getAccountRC":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAccountRC(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "findContract":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_findContract(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "submitTransactionV1":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_submitTransactionV1(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getAccountNonce":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAccountNonce(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "localNodeInfo":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_localNodeInfo(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getWitness":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getWitness(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "witnessNodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_witnessNodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "witnessSchedule":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_witnessSchedule(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "witnessStake":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_witnessStake(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getDagByCID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getDagByCID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getElection":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getElection(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "electionByBlockHeight":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_electionByBlockHeight(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getTssKey":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getTssKey(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getTssRequests":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getTssRequests(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var rcRecordImplementors = []string{"RcRecord"}

func (ec *executionContext) _RcRecord(ctx context.Context, sel ast.SelectionSet, obj *rcDb.RcRecord) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rcRecordImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RcRecord")
		case "account":
			out.Values[i] = ec._RcRecord_account(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "amount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RcRecord_amount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "block_height":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RcRecord_block_height(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "max_rcs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RcRecord_max_rcs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionOperationImplementors = []string{"TransactionOperation"}

func (ec *executionContext) _TransactionOperation(ctx context.Context, sel ast.SelectionSet, obj *transactions.TransactionOperation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionOperationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionOperation")
		case "required_auths":
			out.Values[i] = ec._TransactionOperation_required_auths(ctx, field, obj)
		case "type":
			out.Values[i] = ec._TransactionOperation_type(ctx, field, obj)
		case "index":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionOperation_index(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "data":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionOperation_data(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionOutputImplementors = []string{"TransactionOutput"}

func (ec *executionContext) _TransactionOutput(ctx context.Context, sel ast.SelectionSet, obj *transactions.TransactionOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionOutputImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionOutput")
		case "index":
			out.Values[i] = ec._TransactionOutput_index(ctx, field, obj)
		case "id":
			out.Values[i] = ec._TransactionOutput_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionRecordImplementors = []string{"TransactionRecord"}

func (ec *executionContext) _TransactionRecord(ctx context.Context, sel ast.SelectionSet, obj *transactions.TransactionRecord) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionRecordImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionRecord")
		case "id":
			out.Values[i] = ec._TransactionRecord_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "anchr_height":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionRecord_anchr_height(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "anchr_index":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionRecord_anchr_index(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "anchr_id":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionRecord_anchr_id(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "anchr_ts":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionRecord_anchr_ts(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			out.Values[i] = ec._TransactionRecord_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ops":
			out.Values[i] = ec._TransactionRecord_ops(ctx, field, obj)
		case "op_types":
			out.Values[i] = ec._TransactionRecord_op_types(ctx, field, obj)
		case "first_seen":
			out.Values[i] = ec._TransactionRecord_first_seen(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "nonce":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionRecord_nonce(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "rc_limit":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionRecord_rc_limit(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "required_auths":
			out.Values[i] = ec._TransactionRecord_required_auths(ctx, field, obj)
		case "required_posting_auths":
			out.Values[i] = ec._TransactionRecord_required_posting_auths(ctx, field, obj)
		case "status":
			out.Values[i] = ec._TransactionRecord_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ledger":
			out.Values[i] = ec._TransactionRecord_ledger(ctx, field, obj)
		case "ledger_actions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TransactionRecord_ledger_actions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "output":
			out.Values[i] = ec._TransactionRecord_output(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionSubmitResultImplementors = []string{"TransactionSubmitResult"}

func (ec *executionContext) _TransactionSubmitResult(ctx context.Context, sel ast.SelectionSet, obj *TransactionSubmitResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionSubmitResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionSubmitResult")
		case "id":
			out.Values[i] = ec._TransactionSubmitResult_id(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tssKeyImplementors = []string{"TssKey"}

func (ec *executionContext) _TssKey(ctx context.Context, sel ast.SelectionSet, obj *TssKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tssKeyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TssKey")
		case "id":
			out.Values[i] = ec._TssKey_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._TssKey_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "PublicKey":
			out.Values[i] = ec._TssKey_PublicKey(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Owner":
			out.Values[i] = ec._TssKey_Owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Algo":
			out.Values[i] = ec._TssKey_Algo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreatedHeight":
			out.Values[i] = ec._TssKey_CreatedHeight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tssRequestImplementors = []string{"TssRequest"}

func (ec *executionContext) _TssRequest(ctx context.Context, sel ast.SelectionSet, obj *TssRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tssRequestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TssRequest")
		case "id":
			out.Values[i] = ec._TssRequest_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._TssRequest_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "keyId":
			out.Values[i] = ec._TssRequest_keyId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "msg":
			out.Values[i] = ec._TssRequest_msg(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sig":
			out.Values[i] = ec._TssRequest_sig(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var witnessImplementors = []string{"Witness"}

func (ec *executionContext) _Witness(ctx context.Context, sel ast.SelectionSet, obj *witnesses.Witness) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, witnessImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Witness")
		case "account":
			out.Values[i] = ec._Witness_account(ctx, field, obj)
		case "height":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Witness_height(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "did_keys":
			out.Values[i] = ec._Witness_did_keys(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "enabled":
			out.Values[i] = ec._Witness_enabled(ctx, field, obj)
		case "git_commit":
			out.Values[i] = ec._Witness_git_commit(ctx, field, obj)
		case "net_id":
			out.Values[i] = ec._Witness_net_id(ctx, field, obj)
		case "peer_id":
			out.Values[i] = ec._Witness_peer_id(ctx, field, obj)
		case "protocol_version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Witness_protocol_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "ts":
			out.Values[i] = ec._Witness_ts(ctx, field, obj)
		case "tx_id":
			out.Values[i] = ec._Witness_tx_id(ctx, field, obj)
		case "version_id":
			out.Values[i] = ec._Witness_version_id(ctx, field, obj)
		case "gateway_key":
			out.Values[i] = ec._Witness_gateway_key(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var witnessSlotImplementors = []string{"WitnessSlot"}

func (ec *executionContext) _WitnessSlot(ctx context.Context, sel ast.SelectionSet, obj *state_engine.WitnessSlot) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, witnessSlotImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WitnessSlot")
		case "account":
			out.Values[i] = ec._WitnessSlot_account(ctx, field, obj)
		case "bn":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WitnessSlot_bn(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNActionRecord2vscnodemodulesdbvscledgerActionRecord(ctx context.Context, sel ast.SelectionSet, v ledger_db.ActionRecord) graphql.Marshaler {
	return ec._ActionRecord(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNContract2vscnodemodulesdbvsccontractsContract(ctx context.Context, sel ast.SelectionSet, v contracts.Contract) graphql.Marshaler {
	return ec._Contract(ctx, sel, &v)
}

func (ec *executionContext) marshalNContractOutput2vscnodemodulesdbvsccontractsContractOutput(ctx context.Context, sel ast.SelectionSet, v contracts.ContractOutput) graphql.Marshaler {
	return ec._ContractOutput(ctx, sel, &v)
}

func (ec *executionContext) marshalNContractOutputResult2vscnodemodulesdbvsccontractsContractOutputResult(ctx context.Context, sel ast.SelectionSet, v contracts.ContractOutputResult) graphql.Marshaler {
	return ec._ContractOutputResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNContractOutputResult2vscnodemodulesdbvsccontractsContractOutputResult(ctx context.Context, sel ast.SelectionSet, v []contracts.ContractOutputResult) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContractOutputResult2vscnodemodulesdbvsccontractsContractOutputResult(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNDateTime2timeTime(ctx context.Context, v any) (time.Time, error) {
	res, err := model.UnmarshalDateTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	res := model.MarshalDateTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNElectionMember2vscnodemodulesdbvscelectionsElectionMember(ctx context.Context, sel ast.SelectionSet, v elections.ElectionMember) graphql.Marshaler {
	return ec._ElectionMember(ctx, sel, &v)
}

func (ec *executionContext) marshalNElectionMember2vscnodemodulesdbvscelectionsElectionMember(ctx context.Context, sel ast.SelectionSet, v []elections.ElectionMember) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNElectionMember2vscnodemodulesdbvscelectionsElectionMember(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNElectionResult2vscnodemodulesdbvscelectionsElectionResult(ctx context.Context, sel ast.SelectionSet, v elections.ElectionResult) graphql.Marshaler {
	return ec._ElectionResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNElectionResult2vscnodemodulesdbvscelectionsElectionResult(ctx context.Context, sel ast.SelectionSet, v *elections.ElectionResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ElectionResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt642vscnodemodulesgqlmodelInt64(ctx context.Context, v any) (model.Int64, error) {
	var res model.Int64
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt642vscnodemodulesgqlmodelInt64(ctx context.Context, sel ast.SelectionSet, v model.Int64) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNJSON2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJSON2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLedgerRecord2vscnodemodulesdbvscledgerLedgerRecord(ctx context.Context, sel ast.SelectionSet, v ledger_db.LedgerRecord) graphql.Marshaler {
	return ec._LedgerRecord(ctx, sel, &v)
}

func (ec *executionContext) marshalNOpLogEvent2vscnodemodulesledgersystemOpLogEvent(ctx context.Context, sel ast.SelectionSet, v ledgerSystem.OpLogEvent) graphql.Marshaler {
	return ec._OpLogEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNPostingJsonKeys2vscnodemodulesdbvscwitnessesPostingJsonKeys(ctx context.Context, sel ast.SelectionSet, v witnesses.PostingJsonKeys) graphql.Marshaler {
	return ec._PostingJsonKeys(ctx, sel, &v)
}

func (ec *executionContext) marshalNPostingJsonKeys2vscnodemodulesdbvscwitnessesPostingJsonKeys(ctx context.Context, sel ast.SelectionSet, v []witnesses.PostingJsonKeys) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPostingJsonKeys2vscnodemodulesdbvscwitnessesPostingJsonKeys(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (*string, error) {
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTransactionOutput2vscnodemodulesdbvsctransactionsTransactionOutput(ctx context.Context, sel ast.SelectionSet, v transactions.TransactionOutput) graphql.Marshaler {
	return ec._TransactionOutput(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransactionRecord2vscnodemodulesdbvsctransactionsTransactionRecord(ctx context.Context, sel ast.SelectionSet, v transactions.TransactionRecord) graphql.Marshaler {
	return ec._TransactionRecord(ctx, sel, &v)
}

func (ec *executionContext) marshalNTssRequest2vscnodemodulesgqlgqlgenTssRequest(ctx context.Context, sel ast.SelectionSet, v TssRequest) graphql.Marshaler {
	return ec._TssRequest(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNUint642vscnodemodulesgqlmodelUint64(ctx context.Context, v any) (model.Uint64, error) {
	var res model.Uint64
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint642vscnodemodulesgqlmodelUint64(ctx context.Context, sel ast.SelectionSet, v model.Uint64) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUint642vscnodemodulesgqlmodelUint64(ctx context.Context, v any) ([]model.Uint64, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.Uint64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUint642vscnodemodulesgqlmodelUint64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNUint642vscnodemodulesgqlmodelUint64(ctx context.Context, sel ast.SelectionSet, v []model.Uint64) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNUint642vscnodemodulesgqlmodelUint64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWitness2vscnodemodulesdbvscwitnessesWitness(ctx context.Context, sel ast.SelectionSet, v witnesses.Witness) graphql.Marshaler {
	return ec._Witness(ctx, sel, &v)
}

func (ec *executionContext) marshalNWitness2vscnodemodulesdbvscwitnessesWitness(ctx context.Context, sel ast.SelectionSet, v []witnesses.Witness) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWitness2vscnodemodulesdbvscwitnessesWitness(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWitnessSlot2vscnodemodulesstateprocessingWitnessSlot(ctx context.Context, sel ast.SelectionSet, v state_engine.WitnessSlot) graphql.Marshaler {
	return ec._WitnessSlot(ctx, sel, &v)
}

func (ec *executionContext) marshalNWitnessSlot2vscnodemodulesstateprocessingWitnessSlot(ctx context.Context, sel ast.SelectionSet, v []state_engine.WitnessSlot) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWitnessSlot2vscnodemodulesstateprocessingWitnessSlot(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOActionRecord2vscnodemodulesdbvscledgerActionRecord(ctx context.Context, sel ast.SelectionSet, v []ledger_db.ActionRecord) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNActionRecord2vscnodemodulesdbvscledgerActionRecord(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAsset2vscnodemodulesdbvscledgerAsset(ctx context.Context, v any) (*ledger_db.Asset, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := ledger_db.Asset(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAsset2vscnodemodulesdbvscledgerAsset(ctx context.Context, sel ast.SelectionSet, v *ledger_db.Asset) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) marshalOBalanceRecord2vscnodemodulesdbvscledgerBalanceRecord(ctx context.Context, sel ast.SelectionSet, v *ledger_db.BalanceRecord) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BalanceRecord(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOContract2vscnodemodulesdbvsccontractsContract(ctx context.Context, sel ast.SelectionSet, v []contracts.Contract) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContract2vscnodemodulesdbvsccontractsContract(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOContractOutput2vscnodemodulesdbvsccontractsContractOutput(ctx context.Context, sel ast.SelectionSet, v []contracts.ContractOutput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContractOutput2vscnodemodulesdbvsccontractsContractOutput(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOContractOutputFilter2vscnodemodulesgqlgqlgenContractOutputFilter(ctx context.Context, v any) (*ContractOutputFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputContractOutputFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOElectionResult2vscnodemodulesdbvscelectionsElectionResult(ctx context.Context, sel ast.SelectionSet, v *elections.ElectionResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ElectionResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFindContractFilter2vscnodemodulesgqlgqlgenFindContractFilter(ctx context.Context, v any) (*FindContractFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFindContractFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt642vscnodemodulesgqlmodelInt64(ctx context.Context, v any) (*model.Int64, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Int64)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt642vscnodemodulesgqlmodelInt64(ctx context.Context, sel ast.SelectionSet, v *model.Int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOLedgerAction2vscnodemodulesgqlgqlgenLedgerAction(ctx context.Context, sel ast.SelectionSet, v []*LedgerAction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLedgerAction2vscnodemodulesgqlgqlgenLedgerAction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLedgerAction2vscnodemodulesgqlgqlgenLedgerAction(ctx context.Context, sel ast.SelectionSet, v *LedgerAction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LedgerAction(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLedgerActionsFilter2vscnodemodulesgqlgqlgenLedgerActionsFilter(ctx context.Context, v any) (*LedgerActionsFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLedgerActionsFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLedgerRecord2vscnodemodulesdbvscledgerLedgerRecord(ctx context.Context, sel ast.SelectionSet, v []ledger_db.LedgerRecord) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLedgerRecord2vscnodemodulesdbvscledgerLedgerRecord(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOLedgerTxFilter2vscnodemodulesgqlgqlgenLedgerTxFilter(ctx context.Context, v any) (*LedgerTxFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLedgerTxFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLocalNodeInfo2vscnodemodulesgqlgqlgenLocalNodeInfo(ctx context.Context, sel ast.SelectionSet, v *LocalNodeInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LocalNodeInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMap2vscnodemodulesgqlmodelMap(ctx context.Context, v any) (model.Map, error) {
	if v == nil {
		return nil, nil
	}
	var res model.Map
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2vscnodemodulesgqlmodelMap(ctx context.Context, sel ast.SelectionSet, v model.Map) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalONonceRecord2vscnodemodulesdbvscnoncesNonceRecord(ctx context.Context, sel ast.SelectionSet, v *nonces.NonceRecord) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NonceRecord(ctx, sel, v)
}

func (ec *executionContext) marshalOOpLogEvent2vscnodemodulesledgersystemOpLogEvent(ctx context.Context, sel ast.SelectionSet, v []ledgerSystem.OpLogEvent) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOpLogEvent2vscnodemodulesledgersystemOpLogEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOOpLogEvent2vscnodemodulesledgersystemOpLogEvent(ctx context.Context, sel ast.SelectionSet, v *[]ledgerSystem.OpLogEvent) graphql.Marshaler {
	return ec.marshalOOpLogEvent2vscnodemodulesledgersystemOpLogEvent(ctx, sel, *v)
}

func (ec *executionContext) marshalORcRecord2vscnodemodulesdbvscrcsRcRecord(ctx context.Context, sel ast.SelectionSet, v *rcDb.RcRecord) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RcRecord(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTransactionFilter2vscnodemodulesgqlgqlgenTransactionFilter(ctx context.Context, v any) (*TransactionFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTransactionOperation2vscnodemodulesdbvsctransactionsTransactionOperation(ctx context.Context, sel ast.SelectionSet, v transactions.TransactionOperation) graphql.Marshaler {
	return ec._TransactionOperation(ctx, sel, &v)
}

func (ec *executionContext) marshalOTransactionOperation2vscnodemodulesdbvsctransactionsTransactionOperation(ctx context.Context, sel ast.SelectionSet, v []transactions.TransactionOperation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTransactionOperation2vscnodemodulesdbvsctransactionsTransactionOperation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTransactionOutput2vscnodemodulesdbvsctransactionsTransactionOutput(ctx context.Context, sel ast.SelectionSet, v []transactions.TransactionOutput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionOutput2vscnodemodulesdbvsctransactionsTransactionOutput(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTransactionRecord2vscnodemodulesdbvsctransactionsTransactionRecord(ctx context.Context, sel ast.SelectionSet, v []transactions.TransactionRecord) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactionRecord2vscnodemodulesdbvsctransactionsTransactionRecord(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTransactionStatus2vscnodemodulesdbvsctransactionsTransactionStatus(ctx context.Context, v any) (*transactions.TransactionStatus, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := transactions.TransactionStatus(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTransactionStatus2vscnodemodulesdbvsctransactionsTransactionStatus(ctx context.Context, sel ast.SelectionSet, v *transactions.TransactionStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) marshalOTransactionSubmitResult2vscnodemodulesgqlgqlgenTransactionSubmitResult(ctx context.Context, sel ast.SelectionSet, v *TransactionSubmitResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionSubmitResult(ctx, sel, v)
}

func (ec *executionContext) marshalOTssKey2vscnodemodulesgqlgqlgenTssKey(ctx context.Context, sel ast.SelectionSet, v *TssKey) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TssKey(ctx, sel, v)
}

func (ec *executionContext) marshalOTssRequest2vscnodemodulesgqlgqlgenTssRequest(ctx context.Context, sel ast.SelectionSet, v []TssRequest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTssRequest2vscnodemodulesgqlgqlgenTssRequest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOUint642vscnodemodulesgqlmodelUint64(ctx context.Context, v any) (*model.Uint64, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Uint64)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUint642vscnodemodulesgqlmodelUint64(ctx context.Context, sel ast.SelectionSet, v *model.Uint64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOWitness2vscnodemodulesdbvscwitnessesWitness(ctx context.Context, sel ast.SelectionSet, v *witnesses.Witness) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Witness(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
