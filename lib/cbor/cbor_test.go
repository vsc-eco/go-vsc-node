package cbor_test

import (
	"bytes"
	"fmt"
	"math/big"
	"testing"
	cbor "vsc-node/lib/cbor"

	"github.com/stretchr/testify/assert"
)

func TestCborDecode(t *testing.T) {
	data := []byte{
		0xa4, 0x62, 0x74, 0x78, 0xa2, 0x62, 0x6f, 0x70, 0x68, 0x74, 0x72, 0x61,
		0x6e, 0x73, 0x66, 0x65, 0x72, 0x67, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61,
		0x64, 0xa4, 0x62, 0x74, 0x6b, 0x64, 0x48, 0x49, 0x56, 0x45, 0x62, 0x74,
		0x6f, 0x78, 0x3b, 0x64, 0x69, 0x64, 0x3a, 0x70, 0x6b, 0x68, 0x3a, 0x65,
		0x69, 0x70, 0x31, 0x35, 0x35, 0x3a, 0x31, 0x3a, 0x30, 0x78, 0x38, 0x38,
		0x45, 0x42, 0x42, 0x36, 0x34, 0x43, 0x32, 0x36, 0x34, 0x41, 0x46, 0x66,
		0x31, 0x30, 0x31, 0x34, 0x31, 0x31, 0x34, 0x39, 0x46, 0x39, 0x37, 0x37,
		0x30, 0x46, 0x38, 0x44, 0x36, 0x34, 0x34, 0x43, 0x39, 0x44, 0x38, 0x36,
		0x43, 0x35, 0x64, 0x66, 0x72, 0x6f, 0x6d, 0x78, 0x3b, 0x64, 0x69, 0x64,
		0x3a, 0x70, 0x6b, 0x68, 0x3a, 0x65, 0x69, 0x70, 0x31, 0x35, 0x35, 0x3a,
		0x31, 0x3a, 0x30, 0x78, 0x38, 0x38, 0x45, 0x42, 0x42, 0x36, 0x34, 0x43,
		0x32, 0x36, 0x34, 0x41, 0x46, 0x66, 0x31, 0x30, 0x31, 0x34, 0x31, 0x31,
		0x34, 0x39, 0x46, 0x39, 0x37, 0x37, 0x30, 0x46, 0x38, 0x44, 0x36, 0x34,
		0x34, 0x43, 0x39, 0x44, 0x38, 0x36, 0x43, 0x35, 0x66, 0x61, 0x6d, 0x6f,
		0x75, 0x6e, 0x74, 0x01, 0x63, 0x5f, 0x5f, 0x74, 0x66, 0x76, 0x73, 0x63,
		0x2d, 0x74, 0x78, 0x63, 0x5f, 0x5f, 0x76, 0x63, 0x30, 0x2e, 0x32, 0x67,
		0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0xa4, 0x64, 0x74, 0x79, 0x70,
		0x65, 0x01, 0x65, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x0d, 0x67, 0x69, 0x6e,
		0x74, 0x65, 0x6e, 0x74, 0x73, 0x80, 0x6e, 0x72, 0x65, 0x71, 0x75, 0x69,
		0x72, 0x65, 0x64, 0x5f, 0x61, 0x75, 0x74, 0x68, 0x73, 0x81, 0x78, 0x3b,
		0x64, 0x69, 0x64, 0x3a, 0x70, 0x6b, 0x68, 0x3a, 0x65, 0x69, 0x70, 0x31,
		0x35, 0x35, 0x3a, 0x31, 0x3a, 0x30, 0x78, 0x38, 0x38, 0x45, 0x42, 0x42,
		0x36, 0x34, 0x43, 0x32, 0x36, 0x34, 0x41, 0x46, 0x66, 0x31, 0x30, 0x31,
		0x34, 0x31, 0x31, 0x34, 0x39, 0x46, 0x39, 0x37, 0x37, 0x30, 0x46, 0x38,
		0x44, 0x36, 0x34, 0x34, 0x43, 0x39, 0x44, 0x38, 0x36, 0x43, 0x35,
	}

	reader := bytes.NewReader(data)
	decoder := cbor.NewDecoder(reader)

	// proper DFS traversal of (parsed) data:
	// {
	// 	tx: {
	// 	  op: "transfer", 0
	// 	  payload: {
	// 		tk: "HIVE", 1
	// 		to: "did:pkh:eip155:1:0x88EBB64C264AFf10141149F9770F8D644C9D86C5", 2
	// 		from: "did:pkh:eip155:1:0x88EBB64C264AFf10141149F9770F8D644C9D86C5", 3
	// 		amount: 1 4
	// 	  }
	// 	},
	// 	__t: "vsc-tx", 5
	// 	__v: "0.2", 6
	// 	headers: {
	// 	  type: 1, 7
	// 	  nonce: 13, 8
	// 	  intents: [], 9 // TODO is this supposed to be skipped?
	// 	  required_auths: [
	// 		"did:pkh:eip155:1:0x88EBB64C264AFf10141149F9770F8D644C9D86C5" 10
	// 	  ]
	// 	}
	//   }

	/*
		string: [tx op], 0
		string: [tx payload tk], 1
		string: [tx payload to], 2
		string: [tx payload from], 3
		int: [tx payload amount], 4
		string: [__t], 5
		string: [__v], 6
		int: [headers type], 7
		int: [headers nonce], 8
		string: [headers required_auths [0]], 9
	*/

	i := 0

	v := cbor.JoinVisitors(
		cbor.Visitor{
			IntVisitor: func(path []string, val *big.Int) error {

				fmt.Printf("int: %+v, %d\n", path, i)
				if i == 4 {
					assert.Equal(t, []string{"tx", "payload", "amount"}, path)
					assert.Equal(t, val, big.NewInt(1))
					i += 1
				} else if i == 7 {
					assert.Equal(t, []string{"headers", "type"}, path)
					assert.Equal(t, val, big.NewInt(1))
					i += 1
				} else if i == 8 {
					assert.Equal(t, []string{"headers", "nonce"}, path)
					assert.Equal(t, val, big.NewInt(13))
					i += 1
				} else {
					return fmt.Errorf("int should not be called on %d", i)
				}

				return nil
			},
			NilVisitor: func(path []string) error {
				return fmt.Errorf("no nil exists")
			},
			BoolVisitor: func(path []string, val bool) error {
				return fmt.Errorf("no bool exists")
			},
			Float32Visitor: func(path []string, val float32) error {
				return fmt.Errorf("no float32 exists")
			},
			Float64Visitor: func(path []string, val float64) error {
				return fmt.Errorf("no float64 exists")
			},
			EmptyArrayVisitor: func(path []string) error {
				fmt.Printf("empty array: %+v, %d\n", path, i)
				if i == 9 {
					assert.Equal(t, []string{"headers", "intents"}, path)
				} else {
					return fmt.Errorf("empty array should not be called on %d", i)
				}

				return nil
			},
		},
		cbor.NewBytesCollector(func(path []string, val []byte) error {
			return fmt.Errorf("no bytes exists")
		}),
		cbor.NewStringCollector(func(path []string, val string) error {
			fmt.Printf("string: %+v, %d\n", path, i)

			if i == 0 {
				assert.Equal(t, []string{"tx", "op"}, path)
				assert.Equal(t, "transfer", val)
				i += 1
			} else if i == 1 {
				assert.Equal(t, []string{"tx", "payload", "tk"}, path)
				assert.Equal(t, "HIVE", val)
				i += 1
			} else if i == 2 {
				assert.Equal(t, []string{"tx", "payload", "to"}, path)
				assert.Equal(t, "did:pkh:eip155:1:0x88EBB64C264AFf10141149F9770F8D644C9D86C5", val)
				i += 1
			} else if i == 3 {
				assert.Equal(t, []string{"tx", "payload", "from"}, path)
				assert.Equal(t, "did:pkh:eip155:1:0x88EBB64C264AFf10141149F9770F8D644C9D86C5", val)
				i += 1
			} else if i == 9 {
				assert.Equal(t, []string{"headers", "required_auths", "[0]"}, path)
				assert.Equal(t, "did:pkh:eip155:1:0x88EBB64C264AFf10141149F9770F8D644C9D86C5", val)
				i += 1
			} else if i == 5 {
				assert.Equal(t, []string{"__t"}, path)
				assert.Equal(t, val, "vsc-tx")
				i += 1
			} else if i == 6 {
				assert.Equal(t, []string{"__v"}, path)
				assert.Equal(t, val, "0.2")
				i += 1
			} else {
				return fmt.Errorf("string should not be called on %d", i)
			}

			return nil
		}),
	)

	err := decoder.Decode(v)
	assert.Nil(t, err)
}
